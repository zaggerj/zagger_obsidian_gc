---
created: 2023-11-06T08:20
updated: 2023-11-06T08:20
---
现在我们已经知道了如何从其它地方 `pull` 提交记录，以及如何 `push` 我们自己的变更。看起来似乎没什么难度，但是为何还会让人们如此困惑呢？

困难来自于远程库提交历史的**偏离**。在讨论这个问题的细节前，我们先来看一个例子……

假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目**旧版**的代码，与远程仓库最新的代码不匹配了。

这种情况下, `git push` 就不知道该如何操作了。如果你执行 `git push`，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，异或由于你的提交已经过时而直接忽略你的提交？

因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 `push` 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。
![[Pasted image 20231102145824.png]] ![[Pasted image 20231102145832.png]]

那该如何解决这个问题呢？很简单，你需要做的就是使你的工作基于最新的远程分支。

有许多方法做到这一点呢，不过最直接的方法就是通过 rebase 调整你的工作。咱们继续，看看怎么 rebase！


![[Pasted image 20231102145919.png]]

Git fetch 将 o/master 更新到跟远程仓库一致的 c 2 更新，master 还在 c 3
Git rebase o/masetr  master 暂存 c 3 提交，基于 o/master 的最新提交 c 2，然后产生合并之后的新提交 c 3', 此时 master 分支处于 c 3'，而o/master 处于 c 2
Git push 将本地 master 同步到远程仓库，成功之后，本地远程仓库 o/masetr 也更新到 c 3'提交。


![[Pasted image 20231102150542.png]]


还有其它的方法可以在远程仓库变更了以后更新我的工作吗? 当然有，我们还可以使用 `merge`

尽管 `git merge` 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。

看下演示...

![[Pasted image 20231102150924.png]]

解释过程：
Git fetch 更新同步本地远程分支o/master 的提交到 c 2，此时
git merge o/master 合并本地远程分支 o/master，产生了一个新的提交 c 4，他有两个父提交分别是 c 3 和 c 2，这时本地 master 分支指向，c 4，而 o/master 本地远程分支指向还是 c 2；
Git push 同步本地 master 分支到远程仓库中，成功之后，本地远程分支 o/master 也同步到 c 4 上。
![[Pasted image 20231102152043.png]]

很好！但是要敲那么多命令，有没有更简单一点的？

当然 —— 前面已经介绍过 `git pull` 就是 fetch 和 merge 的简写，类似的 `git pull --rebase` 就是 fetch 和 rebase 的简写！

让我们看看简写命令是如何工作的。

![[Pasted image 20231102152924.png]]

实事证明
Git pull --rebase 就是
Git fetch
Git rebase o/master

Git rebase o/master 过程：将 c 3 暂存，然后基于 c 2，将 c 3 跟 c 2 合并解决冲突之后，产生最新的 c 3'，放到 c 2 的后面，一起成为本地 master 本地合并之后的提交情况

![[Pasted image 20231102153124.png]]