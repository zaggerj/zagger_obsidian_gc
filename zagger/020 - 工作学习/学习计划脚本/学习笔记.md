---
created: 2023-11-03T22:29
updated: 2023-11-06T12:24
---

## TODOLIST：
#todo
* [ ] 1.  [Postcatlab/postcat: Postcat 是一个可扩展的 API 工具平台。集合基础的 API 管理和测试功能，并且可以通过插件简化你的 API 开发工作，让你可以更快更好地创建 API。An extensible API tool. (github.com)](https://github.com/Postcatlab/postcat?utm_campaign=%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9&utm_medium=%E7%BA%BF%E4%B8%8A%E6%8E%A8%E5%B9%BF&utm_source=%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9&gio_link_id=QReKB8No)
* [ ] 2. 最新的规范草案请见 [https://tc39.es/ecma262/](https://tc39.es/ecma262/)。
* [ ] 3. 想了解最新最前沿的功能，包括“即将纳入规范的”（所谓的 “stage 3”），请看这里的提案 [https://github.com/tc39/proposals](https://github.com/tc39/proposals)。
* [ ] 4. 当然，如果你正在做浏览器相关的开发工作，那么本教程的 [第二部分](https://zh.javascript.info/browser-environment) 涵盖了其他规范。
* [ ] 5. **MDN（Mozilla）JavaScript 索引** 是一个带有用例和其他信息的主要的手册。它是一个获取关于个别语言函数、方法等深入信息的很好的信息来源。你可以在 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference) 阅读它。不过，利用互联网搜索通常是最好的选择。只需在查询时输入“MDN [关键字]”，例如 [https://google.com/search?q=MDN+parseInt](https://google.com/search?q=MDN+parseInt) 搜索 `parseInt` 函数。
* [ ] 6. 要查看它们在基于浏览器的引擎及其他引擎中的支持情况，请看：
	- [https://caniuse.com](https://caniuse.com/) —— 每个功能的支持表，例如，查看哪个引擎支持现代加密（cryptography）函数：[https://caniuse.com/#feat=cryptography](https://caniuse.com/#feat=cryptography)。
	- [https://kangax.github.io/compat-table](https://kangax.github.io/compat-table) —— 一份列有语言功能以及引擎是否支持这些功能的表格。
* [ ] 7. deb包 img包 ios包 rpm包 等等
* [ ] 8. html标签特性attribute
* [ ] 9. JavaScript 引擎并没有假设在方括号 `[...]` 前有一个分号。因此，最后一个示例中的代码被视为了单个语句。
* [ ] 10. 现代模式，"use strict"
* [ ] 11. let 声明两次会触发 error
* [ ] 12. ![[Pasted image 20231010143815.png]]
13. [ ] JavaScript 的变量命名有两个限制：
	* 变量名称必须仅包含字母、数字、符号 `$` 和 `_`。
	*  首字符必须非数字。
14. [ ] 如果命名包括多个单词，通常采用驼峰式命名法（[camelCase](https://en.wikipedia.org/wiki/CamelCase)）。
15. [ ] 区分大小写，命名为 `apple` 和 `APPLE` 的变量是不同的两个变量。
16. [ ] 允许非英文字母，但不推荐，可以使用任何语言，包括西里尔字母（cyrillic letters）甚至是象形文字，就像这样：``` `let` имя `=` `'...'``;` `let` 我 `=` `'...'``;` ```
17. [ ] 保留字，有一张 [保留字列表](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords)，这张表中的保留字无法用作变量命名，因为它们被用于编程语言本身了。比如，`let`、`class`、`return`、`function` 都被保留了。
18. [ ] 未采用 `use strict` 下的赋值，而可以简单地通过赋值来创建一个变量。这是个糟糕的做法，严格模式下会报错。
19. [ ] [常量](https://zh.javascript.info/variables#chang-liang)声明一个常数（不变）变量，可以使用 `const` 而非 `let`：
20. [ ] 一个普遍的做法是将常量用作别名，以便记住那些在执行之前就已知的难以记住的值。使用大写字母和下划线来命名这些常量。换句话说，大写命名的常量仅用作“硬编码（hard-coded）”值的别名；`pageLoadTime` 的值在页面加载之前是未知的，所以采用常规命名。但是它仍然是个常量，因为赋值之后不会改变。我们通常用大写字母表示“硬编码（hard-coded）”的常量。或者，换句话说就是，当值在执行之前或在被写入代码的时候，我们就知道值是什么了。它在某种意义上不会随着代码的执行而改变。但与 `birthday` 相比，它还是有一定的可变性：它是计算出来的，因此我们应该使用小写。
21. [ ] 一些可以遵循的规则：
	- 使用易读的命名，比如 `userName` 或者 `shoppingCart`。
	- 离诸如 `a`、`b`、`c` 这种缩写和短名称远一点，除非你真的知道你在干什么。
	- 变量名在能够准确描述变量的同时要足够简洁。不好的例子就是 `data` 和 `value`，这样的名称等于什么都没说。如果能够非常明显地从上下文知道数据和值所表达的含义，这样使用它们也是可以的。
	- 脑海中的术语要和团队保持一致。如果网站的访客称为“用户”，则我们采用相关的变量命名，比如 `currentUser` 或者 `newUser`，而不要使用 `currentVisitor` 或者一个 `newManInTown`
22. [ ] 额外声明一个变量绝对是利大于弊的。现代的 JavaScript 压缩器和浏览器都能够很好地对代码进行优化，所以不会产生性能问题。为不同的值使用不同的变量可以帮助引擎对代码进行优化。
23. [ ] 称为“动态类型”（dynamically typed）的编程语言，意思是虽然编程语言中有不同的数据类型，但是你定义的变量并不会在定义后，被限制为某一数据类型。
24. [ ] `**` 幂 （ES2016 提案）,`NaN ** 0` 结果为 `1`
25. [ ] 数学运算是安全的,在 JavaScript 中做数学运算是安全的。我们可以做任何事：除以 0，将非数字字符串视为数字，等等。脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 `NaN` 的结果。
26. [ ] ## [Number 类型](https://zh.javascript.info/types#number-lei-xing)``` `let` n `=` `123``;` n `=` `12.345``;` ```_number_ 类型代表整数和浮点数。数字可以有很多操作，比如，乘法 `*`、除法 `/`、加法 `+`、减法 `-` 等等。除了常规的数字，还包括所谓的“特殊数值（“special numeric values”）”也属于这种类型：`Infinity`、`-Infinity` 和 `NaN`。
27. [ ] `BigInt` 类型是最近被添加到 JavaScript 语言中的，用于表示任意长度的整数。
28. [ ] “number” 类型无法安全地表示大于 `(253-1)`（即 `9007199254740991`），或小于 `-(253-1)` 的整数。更准确的说，“number” 类型可以存储更大的整数（最多 `1.7976931348623157 * 10308`），但超出安全整数范围 `±(253-1)` 会出现精度问题，因为并非所有数字都适合固定的 64 位存储。因此，可能存储的是“近似值”。console`.``log``(``9007199254740991` `+` `1``)``;` `// 9007199254740992` console`.``log``(``9007199254740991` `+` `2``)``;` `// 9007199254740992`
29. [ ] 可以通过将 `n` 附加到整数字段的末尾来创建 `BigInt` 值。``` `// 尾部的 "n" 表示这是一个 BigInt 类型` `const` bigInt `=` `1234567890123456789012345678901234567890n``;` ```
30. [ ] 反引号是 **功能扩展** 引号。它们允许我们通过将变量和表达式包装在 `${…}` 中，来将它们嵌入到字符串中。
31. [ ] [null 值](https://zh.javascript.info/types#null-zhi)JavaScript 中的 `null` 仅仅是一个代表“无”、“空”或“值未知”的特殊值。上面的代码表示 `age` 是未知的。相比较于其他编程语言，JavaScript 中的 `null` 不是一个“对不存在的 `object` 的引用”或者 “null 指针”。
32. [ ] `undefined` 的含义是 `未被赋值`。
33. [ ] 从技术上讲，可以显式地将 `undefined` 赋值给变量，但是不建议这样做。通常，使用 `null` 将一个“空”或者“未知”的值写入变量中，而 `undefined` 则保留作为未进行初始化的事物的默认初始值。
34. [ ] 对 `typeof x` 的调用会以字符串的形式返回数据类型
	1. [ ] `Math` 是一个提供数学运算的内建 `object`。我们会在 [数字类型](https://zh.javascript.info/number) 一节中学习它。此处仅作为一个 `object` 的示例。
	2. [ ] `typeof null` 的结果为 `"object"`。这是官方承认的 `typeof` 的错误，这个问题来自于 JavaScript 语言的早期阶段，并为了兼容性而保留了下来。`null` 绝对不是一个 `object`。`null` 有自己的类型，它是一个特殊值。`typeof` 的行为在这里是错误的。
	3. [ ] `typeof alert` 的结果是 `"function"`，因为 `alert` 在 JavaScript 语言中是一个函数。我们会在下一章学习函数，那时我们会了解到，在 JavaScript 语言中没有一个特别的 “function” 类型。函数隶属于 `object` 类型。但是 `typeof` 会对函数区分对待，并返回 `"function"`。这也是来自于 JavaScript 语言早期的问题。从技术上讲，这种行为是不正确的，但在实际编程中却非常方便。
	4. [ ] `typeof(x)` 语法，你可能还会遇到另一种语法：`typeof(x)`。它与 `typeof x` 相同。简单点说：`typeof` 是一个操作符，不是一个函数。这里的括号不是 `typeof` 的一部分。它是数学运算分组的括号。通常，这样的括号里包含的是一个数学表达式，例如 `(2 + 2)`，但这里它只包含一个参数 `(x)`。从语法上讲，它们允许在 `typeof` 运算符和其参数之间不打空格，有些人喜欢这样的风格。有些人更喜欢用 `typeof(x)`，尽管 `typeof x` 语法更为常见。
35. [ ] `hello ${name}`在javascript里叫 Template Literals，ES6以后才支持，弥补了没有printf的遗憾。  其他语言里一般叫 [string interpolation] ([https://en.wikipedia.org/wi...](https://disq.us/url?url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FString_interpolation%29%3ADmesd7FLala160udAVpUm2mWI8M&cuid=5627578 "https://en.wikipedia.org/wiki/String_interpolation)")
36. [ ] 类型转换：有三种常用的类型转换：转换为 string 类型、转换为 number 类型和转换为 boolean 类型。
	**字符串转换** —— 转换发生在输出内容的时候，也可以通过 `String(value)` 进行显式转换。原始类型值的 string 类型转换通常是很明显的。
	**数字型转换** —— 转换发生在进行算术操作时，也可以通过 `Number(value)` 进行显式转换。
	数字型转换遵循以下规则：
	|值|变成……|
	|---|---|
	|`undefined`|`NaN`|
	|`null`|`0`|
	|`true / false`|`1 / 0`|
	|`string`|“按原样读取”字符串，两端的空白字符（空格、换行符 `\n`、制表符 `\t` 等）会被忽略。空字符串变成 `0`。转换出错则输出 `NaN`。|
	**布尔型转换** —— 转换发生在进行逻辑操作时，也可以通过 `Boolean(value)` 进行显式转换。
	布尔型转换遵循以下规则：
	|值|变成……|
	|---|---|
	|`0`, `null`, `undefined`, `NaN`, `""`|`false`|
	|其他值|`true`|
	上述的大多数规则都容易理解和记忆。人们通常会犯错误的值得注意的例子有以下几个：
	- 对 `undefined` 进行数字型转换时，输出结果为 `NaN`，而非 `0`。
	- 对 `"0"` 和只有空格的字符串（比如：`" "`）进行布尔型转换时，输出结果为 `true`。
	我们在本小节没有讲 object 类型的转换。在我们学习完更多关于 JavaScript 的基础知识后，我们会在专门介绍 object 的章节 [对象 —— 原始值转换](https://zh.javascript.info/object-toprimitive) 中详细讲解 object 类型转换。
37. [ ] 逗号运算符的优先级非常低
	请注意逗号运算符的优先级非常低，比 = 还要低，因此上面你的例子中圆括号非常重要。
	如果没有圆括号：a = 1 + 2, 3 + 4 会先执行 +，将数值相加得到 a = 3, 7，然后赋值运算符 = 执行 a = 3，然后逗号之后的数值 7 不会再执行，它被忽略掉了。相当于 (a = 1 + 2), 3 + 4。
38. [ ] 运算符 `++` 和 `--` 可以置于变量前，也可以置于变量后。
	- 当运算符置于变量后，被称为“后置形式”：`counter++`。
	- 当运算符置于变量前，被称为“前置形式”：`++counter`。
	- 前置形式返回一个新的值，但后置返回原来的值（做加法/减法之前的值）。
	- 自增/自减只能应用于变量。试一下，将其应用于数值（比如 `5++`）则会报错。
39. [ ] [原地修改](https://zh.javascript.info/operators#yuan-di-xiu-gai)所有算术和位运算符都有简短的“修改并赋值”运算符：`/=` 和 `-=` 等。这类运算符的优先级与普通赋值运算符的优先级相同，所以它们在大多数其他运算之后执行：
40. [ ] [链式赋值（Chaining assignments）](https://zh.javascript.info/operators#lian-shi-fu-zhi-chainingassignments)链式赋值从右到左进行计算。首先，对最右边的表达式 `2 + 2` 求值，然后将其赋给左边的变量：`c`、`b` 和 `a`。最后，所有的变量共享一个值
41. [ ] [赋值 = 返回一个值](https://zh.javascript.info/operators#fu-zhi-fan-hui-yi-ge-zhi)，= 是一个运算符，而不是一个有着“魔法”作用的语言结构。
	在 JavaScript 中，所有运算符都会返回一个值。这对于 + 和 - 来说是显而易见的，但对于 = 来说也是如此。
	语句 x = value 将值 value 写入 x 然后返回 value。
42. [ ] 我们知道赋值符号 = 也是一个运算符。从优先级表中可以看到它的优先级非常低，只有 2。这也是为什么，当我们赋值时，比如 x = 2 * 2 + 1，所有的计算先执行，然后 = 才执行，将计算结果存储到 x。
43. [ ] [运算符优先级](https://zh.javascript.info/operators#yun-suan-fu-you-xian-ji)如果一个表达式拥有超过一个运算符，执行的顺序则由 **优先级** 决定。换句话说，所有的运算符中都隐含着优先级顺序。

| 优先级 | 名称     | 符号  |
| ------ | -------- | ----- |
| …      | …        | …     |
| 15     | 一元加号 | `+`   |
| 15     | 一元负号 | `-`   |
| 14     | 求幂     | `**`  |
| 13     | 乘号     | `*`   |
| 13     | 除号     | `/`   |
| 12     | 加号     | `+`   |
| 12     | 减号     | `-`   |
| …      | …        | …     |
| 2      | 赋值符   | `‘=’` |
| …      | …        |       |

^41e57a

	我们可以看到，“一元加号运算符”的优先级是 `15`，高于“二元加号运算符”的优先级 `12`。这也是为什么表达式 `"+apples + +oranges"` 中的一元加号先生效，然后才是二元加法。

#todo
44. [ ]  [数字转化，一元运算符 +](https://zh.javascript.info/operators#shu-zi-zhuan-hua-yi-yuan-yun-suan-fu)
	加号 `+` 有两种形式。一种是上面我们刚刚讨论的二元运算符，还有一种是一元运算符。
	一元运算符加号，或者说，加号 `+` 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 `+` 则会将其转化为数字。
45. [ ]  [用二元运算符 + 连接字符串](https://zh.javascript.info/operators#yong-er-yuan-yun-suan-fu-lian-jie-zi-fu-chuan)
	我们来看一些学校算术未涉及的 JavaScript 运算符的特性。
	通常，加号 `+` 用于求和。
	但是如果加号 `+` 被应用于字符串，它将合并（连接）各个字符串
46. [ ]  [求幂 **](https://zh.javascript.info/operators#qiu-mi)
	
	求幂运算 `a ** b` 将 `a` 提升至 `a` 的 `b` 次幂。
	
	在数学运算中我们将其表示为 ab。
47. [ ] [取余 %](https://zh.javascript.info/operators#qu-yu)

	取余运算符是 `%`，尽管它看起来很像百分数，但实际并无关联。
	
	`a % b` 的结果是 `a` 整除 `b` 的 [余数](https://zh.wikipedia.org/zh-hans/%E4%BD%99%E6%95%B0)。
48. [ ] [术语：“一元运算符”，“二元运算符”，“运算元”](https://zh.javascript.info/operators#shu-yu-yi-yuan-yun-suan-fu-er-yuan-yun-suan-fu-yun-suan-yuan)
	在正式开始前，我们先简单浏览一下常用术语。
	- **运算元** —— 运算符应用的对象。比如说乘法运算 `5 * 2`，有两个运算元：左运算元 `5` 和右运算元 `2`。有时候人们也称其为“参数”而不是“运算元”。
	- 如果一个运算符对应的只有一个运算元，那么它是 **一元运算符**。比如说一元负号运算符（unary negation）`-`，它的作用是对数字进行正负转换：
	    ``` `let` x `=` `1``;`  _x `=` `-`x`;`_ `alert``(` x `)``;` `// -1，一元负号运算符生效` ```   
	- 如果一个运算符拥有两个运算元，那么它是 **二元运算符**。减号还存在二元运算符形式：
	    ``` `let` x `=` `1``,` y `=` `3``;` `alert``(` y `-` x `)``;` `// 2，二元运算符减号做减运算` ```
	    严格地说，在上面的示例中，我们使用一个相同的符号表征了两个不同的运算符：负号运算符，即反转符号的一元运算符，减法运算符，是从另一个数减去一个数的二元运算
49. [ ] 字符串的比较算法非常简单：
	1. 首先比较两个字符串的首位字符大小。
	2. 如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串。算法结束。
	3. 否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较。
	4. 重复上述步骤进行比较，直到比较完成某字符串的所有字符为止。
	5. 如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大。
	6. 非真正的字典顺序，而是 Unicode 编码顺序，在上面的算法中，比较大小的逻辑与字典或电话簿中的排序很像，但也不完全相同。
	比如说，字符串比较对字母大小写是敏感的。大写的 `"A"` 并不等于小写的 `"a"`。哪一个更大呢？实际上小写的 `"a"` 更大。这是因为在 JavaScript 使用的内部编码表中（Unicode），小写字母的字符索引值更大。我们会在 [字符串](https://zh.javascript.info/string) 这章讨论更多关于字符串的细节。
	在上面的第一个例子中，`'Z' > 'A'` 比较在算法的第 1 步就得到了结果。
	
	在第二个例子中，字符串 `Glow` 与 `Glee` 的比较则需要更多步骤，因为需要逐个字符进行比较：
	
	1. `G` 和 `G` 相等。
	2. `l` 和 `l` 相等。
	3. `o` 比 `e` 大，算法停止，第一个字符串大于第二个。
50. [ ] 是的，上面的结果完全打破了你对数学的认识。在最后一行代码显示“`null` 大于等于 0”的情况下，前两行代码中一定会有一个是正确的，然而事实表明它们的结果都是 false。

	为什么会出现这种反常结果，这是因为相等性检查 `'=='` 和普通比较符 `> < >= <=` 的代码逻辑是相互独立的。进行值的比较时，`null` 会被转化为数字，因此它被转化为了 `0`。这就是为什么（3）中 `null >= 0` 返回值是 true，（1）中 `null > 0` 返回值是 false。
	
	另一方面，`undefined` 和 `null` 在相等性检查 `'=='` 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值。这就解释了为什么（2）中 `null == 0` 会返回 false。
51. [ ] [特立独行的 undefined](https://zh.javascript.info/comparison#te-li-du-hang-de-undefined)

	`undefined` 不应该被与其他值进行比较：
	```js
	alert( undefined > 0 ); // false (1) 
	alert( undefined < 0 ); // false (2) 
	alert( undefined == 0 ); // false (3)
	```
	
	
	为何它看起来如此厌恶 0？返回值都是 false！
	
	原因如下：
	
	- `(1)` 和 `(2)` 都返回 `false` 是因为 `undefined` 在比较中被转换为了 `NaN`，而 `NaN` 是一个特殊的数值型值，它与任何值进行比较都会返回 `false`。
	- `(3)` 返回 `false` 是因为这是一个相等性检查，而 `undefined` 只与 `null` 相等，不会与其他值相等。
#todo	
52. [ ]  [总结](https://zh.javascript.info/comparison#zong-jie)
	- 比较运算符始终返回布尔值。
	- 字符串的比较，会按照“词典”顺序逐字符地比较大小。
	- 当对不同类型的值进行比较时，它们会先被转化为数字（不包括严格相等检查）再进行比较。
	- 在非严格相等 `'=='` 下，`null` 和 `undefined` 相等且各自不等于任何其他的值。
	- 在使用 `>` 或 `<` 进行比较时，需要注意变量可能为 `null/undefined` 的情况。比较好的方法是单独检查变量是否等于 `null/undefined`。
53. [ ] 或运算符 `||` 做了如下的事情：**转换布尔值，来决定是否继续走下去，停止运算后，返回初始值**
	- 从左到右依次计算操作数。
	- 处理每一个操作数时，都将其转化为布尔值。如果结果是 `true`，就停止计算，返回这个操作数的初始值。
	- 如果所有的操作数都被计算过（也就是，转换结果都是 `false`），则返回最后一个操作数。
54. [ ]  [与运算寻找第一个假值](https://zh.javascript.info/logical-operators#yu-yun-suan-xun-zhao-di-yi-ge-jia-zhi)

	给出多个参加与运算的值：
	
	`result = value1 && value2 && value3;`
	
	与运算 `&&` 做了如下的事：
	
	- 从左到右依次计算操作数。
	- 在处理每一个操作数时，都将其转化为布尔值。如果结果是 `false`，就停止计算，并返回这个操作数的初始值。
	- 如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。
	
	换句话说，与运算返回第一个假值，如果没有假值就返回最后一个值。
	
	上面的规则和或运算很像。区别就是**与运算返回第一个假值，而或运算返回第一个真值**。
	
	与运算 `&&` 在或运算 `||` 之前进行
	
	与运算 `&&` 的优先级比或运算 `||` 要高。
	
	所以代码 `a && b || c && d` 跟 `&&` 表达式加了括号完全一样：`(a && b) || (c && d)`。
#todo	
55. [ ] 非运算符 `!` 的优先级在所有逻辑运算符里面最高，所以它总是在 `&&` 和 `||` 之前执行。
56. [ ] 空值合并运算符 '??'，`a ?? b` 的结果是：

	- 如果 `a` 是已定义的，则结果为 `a`，
	- 如果 `a` 不是已定义的，则结果为 `b`。
	- `result = (a !== null && a !== undefined) ? a : b;`
57. [ ] [与 || 比较](https://zh.javascript.info/nullish-coalescing-operator#yu-bi-jiao)
	它们之间重要的区别是：
	
	- `||` 返回第一个 **真** 值。
	- `??` 返回第一个 **已定义的** 值。
	- 换句话说，`||` 无法区分 `false`、`0`、空字符串 `""` 和 `null/undefined`。它们都一样 —— 假值（falsy values）。如果其中任何一个是 `||` 的第一个参数，那么我们将得到第二个参数作为结果。
	- 不过在实际中，我们可能只想在变量的值为 `null/undefined` 时使用默认值。也就是说，当该值确实未知或未被设置时。
	- 实际上，高度 `0` 通常是一个有效值，它不应该被替换为默认值。所以 `??` 运算得到的是正确的结果。
	- ## [优先级](https://zh.javascript.info/nullish-coalescing-operator#you-xian-ji)
	
	`??` 运算符的优先级与 `||` 相同，它们的的优先级都为 `4`，详见：[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table)。
	* [?? 与 && 或 || 一起使用](https://zh.javascript.info/nullish-coalescing-operator#yu-huo-yi-qi-shi-yong)出于安全原因，JavaScript 禁止将 `??` 运算符与 `&&` 和 `||` 运算符一起使用，除非使用括号明确指定了优先级。
	* [总结](https://zh.javascript.info/nullish-coalescing-operator#zong-jie)
	- 空值合并运算符 `??` 提供了一种从列表中选择第一个“已定义的”值的简便方式。
	    它被用于为变量分配默认值：
	    ```js
	    // 当 height 的值为 null 或 undefined 时，将 height 的值设置为 100 
	    height = height ?? 100;
		```
	- `??` 运算符的优先级非常低，仅略高于 `?` 和 `'='`，因此在表达式中使用它时请考虑添加括号。 
	- 如果没有明确添加括号，不能将其与 `||` 或 `&&` 一起使用。
	- [表达式与运算符 - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators)
58. [ ] ## [总结](https://zh.javascript.info/iterable#zong-jie)

	可以应用 `for..of` 的对象被称为 **可迭代的**。
	
	- 技术上来说，可迭代对象必须实现 `Symbol.iterator` 方法。
	    - `obj[Symbol.iterator]()` 的结果被称为 **迭代器（iterator）**。由它处理进一步的迭代过程。
	    - 一个迭代器必须有 `next()` 方法，它返回一个 `{done: Boolean, value: any}` 对象，这里 `done:true` 表明迭代结束，否则 `value` 就是下一个值。
	- `Symbol.iterator` 方法会被 `for..of` 自动调用，但我们也可以直接调用它。
	- 内建的可迭代对象例如字符串和数组，都实现了 `Symbol.iterator`。
	- 字符串迭代器能够识别代理对（surrogate pair）。（译注：代理对也就是 UTF-16 扩展字符。）
	
	有索引属性和 `length` 属性的对象被称为 **类数组对象**。这种对象可能还具有其他属性和方法，但是没有数组的内建方法。
	
	如果我们仔细研究一下规范 —— 就会发现大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是“真正的”数组，因为这样抽象度更高。
	
	`Array.from(obj[, mapFn, thisArg])` 将可迭代对象或类数组对象 `obj` 转化为真正的数组 `Array`，然后我们就可以对它应用数组的方法。可选参数 `mapFn` 和 `thisArg` 允许我们将函数应用到每个元素。
	
	Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。
	为对象定义一些非私有的、但又希望只用于内部的方法。
	
> 	由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。
> 	
> 	注意：symbol并不能实现真正的私有变量的效果，只是不能通过常规的遍历方法拿到symbol类型的属性而已
#todo	
59. [ ] 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。上面代码中，`toString()`方法是`Point`类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。
60. [ ] `constructor()`方法默认返回实例对象（即`this`），完全可以指定返回另外一个对象。
61. [ ] 类必须使用`new`调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用`new`也可以执行。
62. [ ] 类的属性和方法，除非显式定义在其本身（即定义在`this`对象上），否则都是定义在原型上（即定义在`class`上）。
63. [ ] - 比较 `x` 值与第一个 `case`（也就是 `value1`）是否严格相等，然后比较第二个 `case`（`value2`）以此类推。
	- 如果相等，`switch` 语句就执行相应 `case` 下的代码块，直到遇到最靠近的 `break` 语句（或者直到 `switch` 语句末尾）。
	- 如果没有符合的 case，则执行 `default` 代码块（如果 `default` 存在）。
	- 强调一下，这里的相等是严格相等。被比较的值必须是相同的类型才能进行匹配。
64. [ ] 第二个变体更容易理解，不是吗？我们通过函数名（`isPrime`）就可以看出函数的行为，而不需要通过代码。人们通常把这样的代码称为 **自描述**。因此，即使我们不打算重用它们，也可以创建函数。函数可以让代码结构更清晰，可读性更强。
65. [ ] 判断质数![[Pasted image 20231013115426.png]]
66. [ ] [转载--给函数取个好名_函数起名-CSDN博客](https://blog.csdn.net/m0_38036750/article/details/126578085)![[Pasted image 20231013115723.png]]
67. [ ] **严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。**
68. [ ] [总结](https://zh.javascript.info/function-expressions#zong-jie)
	- 函数是值。它们可以在代码的任何地方被分配，复制或声明。
	- 如果函数在主代码流中被声明为单独的语句，则称为“函数声明”。
	- 如果该函数是作为表达式的一部分创建的，则称其“函数表达式”。
	- 在执行代码块之前，内部算法会先处理函数声明。所以函数声明在其被声明的代码块内的任何位置都是可见的。
	- 函数表达式在执行流程到达时创建。
	在大多数情况下，当我们需要声明一个函数时，最好使用函数声明，因为函数在被声明之前也是可见的。这使我们在代码组织方面更具灵活性，通常也会使得代码可读性更高。
	所以，仅当函数声明不适合对应的任务时，才应使用函数表达式。在本章中，我们已经看到了几个例子，以后还会看到更多的例子。
69. [ ] 函数自己就变成了一个注释。这种代码被称为 **自描述型** 代码。
70. [ ] jsDoc ：[JSDoc - Wikipedia --- JSDoc - 维基百科](https://en.wikipedia.org/wiki/JSDoc#cite_note-5)
	[Use JSDoc: Index](https://jsdoc.app/)
71. [ ] #TODO    ![[Pasted image 20231016114256.png]]
72. [ ] #TODO 道隐无名。夫唯道善贷且成。翻译： [道德经第四十一章——善贷且成 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/437969463)

#TODO
73. [ ] Polyfill填充 | Transpiler转译器
	1. 新提议：[ECMAScript® 2024 Language Specification (tc39.es)](https://tc39.es/ecma262/)
	2. 规范：[ECMA-262 - Ecma International (ecma-international.org)](https://www.ecma-international.org/publications-and-standards/standards/ecma-262/)
	3.  JavaScript 引擎语言特性当前支持状态： [ECMAScript 6 compatibility table (compat-table.github.io)](https://compat-table.github.io/compat-table/es6/)
	4. **[转译器](https://en.wikipedia.org/wiki/Source-to-source_compiler)** 是一种可以将源码转译成另一种源码的特殊的软件。它可以解析（“阅读和理解”）现代代码，并使用旧的语法结构对其进行重写，进而使其也可以在旧的引擎中工作。
		1. **[Babel](https://babeljs.io/)** 是最著名的转译器之一。
		2. 现代项目构建系统，例如 **[webpack](https://webpack.js.org/)**，提供了在每次代码更改时自动运行转译器的方法，因此很容易将代码转译集成到开发过程中。
	5. **[垫片（Polyfills）](https://zh.javascript.info/polyfills#dian-pian-polyfills)** 新的语言特性可能不仅包括语法结构和运算符，还可能包括**内建函数**。
		1. 由于我们谈论的是新函数，而不是语法更改，因此无需在此处转译任何内容。我们只需要声明缺失的函数。更新/添加新函数的脚本被称为“polyfill”。它“填补”了空白并添加了缺失的实现。
		2. JavaScript 是一种高度动态的语言。脚本可以添加/修改任何函数，甚至包括内建函数。两个有趣的 polyfill 库：
			- [core js](https://github.com/zloirock/core-js) 支持了很多特性，允许只包含需要的特性。
			- [polyfill.io](http://polyfill.io/) 提供带有 polyfill 的脚本的服务，具体取决于特性和用户的浏览器。
	6. 不要忘记使用转译器（如果使用现代语法或运算符）和 polyfill（添加可能缺少的特性）。它们将确保代码能正常工作。[webpack](https://webpack.js.org/) | [babel/babel-loader: 📦 Babel loader for webpack (github.com)](https://github.com/babel/babel-loader)
	7. 展示对各种特征的当前支持情况的工具：
		- [ECMAScript 6 compatibility table (compat-table.github.io)](https://compat-table.github.io/compat-table/es6/) —— 对于原生 JavaScript。
		- [https://caniuse.com/](https://caniuse.com/) —— 对于浏览器相关的函数。
74. [ ] Object（对象）：基础知识
	1. 方括号比点符号更强大。它允许任何属性名和变量，但写起来也更加麻烦。当属性名是已知且简单的时候，就使用点符号。如果我们需要一些更复杂的内容，那么就用方括号。
	2. 属性名跟变量名一样。这种通过变量生成属性的应用场景很常见，在这有一种特殊的 **属性值缩写** 方法，使属性名变得更短。可以用 `name` 来代替 `name:name`。
	3. 变量名不能是编程语言的某个保留字，如 “for”、“let”、“return” 等……，但对象的属性名并不受此限制。简而言之，属性命名没有限制。属性名可以是任何字符串或者 symbol（一种特殊的标志符类型，将在后面介绍）。其他类型会被自动地转换为字符串。
	4. 一个名为 `__proto__` 的属性。我们不能将它设置为一个非对象的值，把它赋值为 `5` 的操作被忽略了。
	5. 读取不存在的属性只会得到 `undefined`。所以我们可以很容易地判断一个属性是否存在
	6. 检查属性是否存在的操作符 `"in"`。语法是：`` `"key"` `in` object ``。`in` 的左边必须是 **属性名**。通常是一个带引号的字符串。如果我们省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名。
	7. 为何会有 `in` 运算符呢？与 `undefined` 进行比较来判断还不够吗？确实，大部分情况下与 `undefined` 进行比较来判断就可以了。但有一个例外情况，这种比对方式会有问题，但 `in` 运算符的判断结果仍是对的。
		```js
			let obj = { test: undefined };
			alert( obj.test ); // 显示 undefined，所以属性不存在？ 
			alert( "test" in obj ); // true，属性存在！
		  ```
	8. 属性 `obj.test` 事实上是存在的，所以 `in` 操作符检查通过。这种情况很少发生，因为通常情况下不应该给对象赋值 `undefined`。我们**通常会用 `null` 来表示未知的或者空的值**。因此，`in` 运算符是代码中的特殊来宾。
	9.  ["for..in" 循环](https://zh.javascript.info/object#forin)为了遍历一个对象的所有键（key），可以使用一个特殊形式的循环：`for..in`。这跟我们在前面学到的 `for(;;)` 循环是完全不一样的东西。语法：
	   ```js
	    for (key in object) {
		 // 对此对象属性中的每个键执行的代码
		}
  	  ```
    10. [像对象一样排序](https://zh.javascript.info/object#xiang-dui-xiang-yi-yang-pai-xu)对象有顺序吗？换句话说，如果我们遍历一个对象，我们获取属性的顺序是和属性添加时的顺序相同吗？这靠谱吗？简短的回答是：“有特别的顺序”：**整数属性会被当做数字进行排序**，**其他属性则按照创建的顺序显示**。![[Pasted image 20231017154522.png]]
75. [ ] **对象引用和复制** ## [总结](https://zh.javascript.info/object-copy#zong-jie)
	对象通过引用被赋值和拷贝。换句话说，一个变量存储的不是“对象的值”，而是一个对值的“引用”（内存地址）。因此，拷贝此类变量或将其作为函数参数传递时，所拷贝的是引用，而不是对象本身。
	所有通过被拷贝的引用的操作（如添加、删除属性）都作用在同一个对象上。为了创建“真正的拷贝”（一个克隆），我们可以使用 `Object.assign` 来做所谓的“浅拷贝”（嵌套对象被通过引用进行拷贝）或者使用“深拷贝”函数，例如 [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)。
76. [ ] 垃圾回收## [总结](https://zh.javascript.info/garbage-collection#zong-jie)主要需要掌握的内容：
	- 垃圾回收是自动完成的，我们不能强制执行或是阻止执行。
	- 当对象是可达状态时，它一定是存在于内存中的。
	- 被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达，正如我们在上面的例子中看到的那样。
	现代引擎实现了垃圾回收的高级算法。
	《The Garbage Collection Handbook: The Art of Automatic Memory Management》（R. Jones 等人著）这本书涵盖了其中一些内容。
	如果你熟悉底层（low-level）编程，关于 V8 引擎垃圾回收器的更详细信息请参阅文章 [V8 之旅：垃圾回收](http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)。
	[V8 博客](http://v8project.blogspot.com/) 还不时发布关于内存管理变化的文章。当然，为了学习更多垃圾收集的相关内容，你最好通过学习 V8 引擎内部知识来进行准备，并阅读一个名为 [Vyacheslav Egorov](http://mrale.ph/) 的 V8 引擎工程师的博客。我之所以说 “V8”，因为网上关于它的文章最丰富的。对于其他引擎，许多方法是相似的，但在垃圾收集上许多方面有所不同。
	当你需要底层的优化时，对引擎有深入了解将很有帮助。在熟悉了这门编程语言之后，把熟悉引擎作为下一步计划是明智之选。
77. [ ] 当我们在代码中用对象表示实体时，就是所谓的 [面向对象编程](https://en.wikipedia.org/wiki/Object-oriented_programming)，简称为 “OOP”。
	OOP 是一门大学问，本身就是一门有趣的科学。怎样选择合适的实体？如何组织它们之间的交互？这就是架构，有很多关于这方面的书，例如 E. Gamma、R. Helm、R. Johnson 和 J. Vissides 所著的《设计模式：可复用面向对象软件的基础》，G. Booch 所著的《面向对象分析与设计》等。
78. [ ] 在没有对象的情况下调用：`this == undefined` 在这种情况下，严格模式下的 `this` 值为 `undefined`。如果我们尝试访问 `this.name`，将会报错。
	在非严格模式的情况下，`this` 将会是 **全局对象**（浏览器中的 `window`，我们稍后会在 [全局对象](https://zh.javascript.info/global-object) 一章中学习它）。这是一个历史行为，`"use strict"` 已经将其修复了。
	通常这种调用是程序出错了。如果在一个函数内部有 `this`，那么通常意味着它是在对象上下文环境中被调用的。
	如上所示，我们可以省略 `"function"`，只写 `sayHi()`。
	说实话，这种表示法还是有些不同。在对象继承方面有一些细微的差别（稍后将会介绍），但目前它们并不重要。在几乎所有的情况下，更短的语法是首选的。
	## [总结](https://zh.javascript.info/object-methods#zong-jie)
	- 存储在对象属性中的函数被称为“方法”。
	- 方法允许对象进行像 `object.doSomething()` 这样的“操作”。
	- 方法可以将对象引用为 `this`。
	`this` 的值是在程序运行时得到的。
	- 一个函数在声明时，可能就使用了 `this`，但是这个 `this` 只有在函数被调用时才会有值。
	- 可以在对象之间复制函数。
	- 以“方法”的语法调用函数时：`object.method()`，调用过程中的 `this` 值是 `object`。
	请注意箭头函数有些特别：它们没有 `this`。在箭头函数内部访问到的 `this` 都是从外部获取的。
79. [ ] 构造函数在技术上是常规函数。不过有两个约定：
	1. 它们的命名以大写字母开头。
	2. 它们只能由 `"new"` 操作符来执行。
	3. 当一个函数被使用 `new` 操作符执行时，它按照以下步骤：
		1. 一个新的空对象被创建并分配给 `this`。
		2. 函数体执行。通常它会修改 `this`，为其添加新的属性。
		3. 返回 `this` 的值。
		4. ![[Pasted image 20231019115008.png]]
		5. 这是构造器的主要目的 —— 实现可重用的对象创建代码。
		6. 让我们再强调一遍 —— 从技术上讲，任何函数（除了箭头函数，它没有自己的 `this`）都可以用作构造器。即可以通过 `new` 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 `new` 来运行。
		7. new function() { … }![[Pasted image 20231019115319.png]]
		8. ## [构造器模式测试：new.target](https://zh.javascript.info/constructor-new#gou-zao-qi-mo-shi-ce-shi-newtarget)
			进阶内容
			本节涉及的语法内容很少使用，除非你想了解所有内容，否则你可以直接跳过该语法。
			在一个函数内部，我们可以使用 `new.target` 属性来检查它是否被使用 `new` 进行调用了。
		9. 它可以被用在函数内部
			1. ![[Pasted image 20231019115514.png]]
		10. 这种方法有时被用在库中以使语法更加灵活。这样人们在调用函数时，无论是否使用了 `new`，程序都能工作。不过，到处都使用它并不是一件好事，因为省略了 `new` 使得很难观察到代码中正在发生什么。而通过 `new` 我们都可以知道这创建了一个新对象。
		11. ## [构造器的 return](https://zh.javascript.info/constructor-new#gou-zao-qi-de-return)
			通常，构造器没有 `return` 语句。它们的任务是将所有必要的东西写入 `this`，并自动转换为结果。
			但是，如果这有一个 `return` 语句，那么规则就简单了：
			- 如果 `return` 返回的是一个对象，则返回这个对象，而不是 `this`。
			- 如果 `return` 返回的是一个原始类型，则忽略。
			换句话说，带有对象的 `return` 返回该对象，在所有其他情况下返回 `this`。
		12. 通常构造器没有 `return` 语句。这里我们主要为了完整性而提及返回对象的特殊行为。![[Pasted image 20231019115854.png]]
		13. 省略括号
			1.![[Pasted image 20231019115939.png]]
		14. ## [总结](https://zh.javascript.info/constructor-new#zong-jie)
			- 构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其命名首字母要大写。
			- 构造函数只能使用 `new` 来调用。这样的调用意味着在开始时创建了空的 `this`，并在最后返回填充了值的 `this`。
			我们可以使用构造函数来创建多个类似的对象。JavaScript 为许多内建的对象提供了构造函数：比如日期 `Date`、集合 `Set` 以及其他我们计划学习的内容。
80. [ ]  可选链 "?."[手把手教你在webpack中，配置两种常用的polyfills配置，以ie11为例，配置babel-loader_babel兼容ie11-CSDN博客](https://blog.csdn.net/weixin_50794208/article/details/130830275)不要过度使用可选链
	我们应该只将 `?.` 使用在一些东西可以不存在的地方。例如，如果根据我们的代码逻辑，`user` 对象必须存在，但 `address` 是可选的，那么我们应该这样写 `user.address?.street`，而不是这样 `user?.address?.street`。那么，如果 `user` 恰巧为 undefined，我们会看到一个编程错误并修复它。否则，如果我们滥用 `?.`，会导致代码中的错误在不应该被消除的地方消除了，这会导致调试更加困难。![[Pasted image 20231019143725.png]]
	* *## [短路效应](https://zh.javascript.info/optional-chaining#duan-lu-xiao-ying) 
	* ![[Pasted image 20231019143839.png]]![[Pasted image 20231019143953.png]]
	* 在这两行代码中，我们首先使用点符号（`userAdmin.admin`）来获取 `admin` 属性，因为我们假定对象 `userAdmin` 存在，因此可以安全地读取它。然后 `?.()` 会检查它左边的部分：如果 `admin` 函数存在，那么就调用运行它（对于 `userAdmin`）。否则（对于 `userGuest`）运算停止，没有报错。
	* 如果我们想使用方括号 `[]` 而不是点符号 `.` 来访问属性，语法 `?.[]` 也可以使用。跟前面的例子类似，它允许从一个可能不存在的对象上安全地读取属性。
	* 此外，我们还可以将 `?.` 跟 `delete` 一起使用：![[Pasted image 20231019144150.png]]
	* 我们可以使用 `?.` 来安全地读取或删除，但不能写入![[Pasted image 20231019144207.png]]
	* ## [总结](https://zh.javascript.info/optional-chaining#zong-jie)
		可选链 `?.` 语法有三种形式：
		1. `obj?.prop` —— 如果 `obj` 存在则返回 `obj.prop`，否则返回 `undefined`。
		2. `obj?.[prop]` —— 如果 `obj` 存在则返回 `obj[prop]`，否则返回 `undefined`。
		3. `obj.method?.()` —— 如果 `obj.method` 存在则调用 `obj.method()`，否则返回 `undefined`。
		正如我们所看到的，这些语法形式用起来都很简单直接。**`?.` 检查左边部分是否为 `null/undefined`，如果不是则继续运算。**
		`?.` 链使我们能够安全地访问嵌套属性。
		但是，我们应该谨慎地使用 `?.`，**根据我们的代码逻辑，仅在当左侧部分不存在也可接受的情况下使用为宜。以保证在代码中有编程上的错误出现时，也不会对我们隐藏**。
81. [ ] symbol 类型
	- 根据规范，只有两种原始类型可以用作对象属性键：
		- 字符串类型
		- symbol 类型
	- 否则，如果使用另一种类型，例如数字，它会被自动转换为字符串。所以 `obj[1]` 与 `obj["1"]` 相同，而 `obj[true]` 与 `obj["true"]` 相同。
	- 到目前为止，我们一直只使用字符串。现在我们来看看 symbol 能给我们带来什么。
	- 总而言之，symbol 是带有可选描述的“原始唯一值”。让我们看看我们可以在哪里使用它们。
	- symbol 不会被自动转换为字符串
	- ![[Pasted image 20231019144810.png]]
	- [“隐藏”属性](https://zh.javascript.info/symbol#yin-cang-shu-xing)，symbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。例如，如果我们使用的是属于第三方代码的 `user` 对象，我们想要给它们添加一些标识符。![[Pasted image 20231019145109.png]]
	- 由于 `user` 对象属于另一个代码库，所以向它们添加字段是不安全的，因为我们可能会影响代码库中的其他预定义行为。但 symbol 属性不会被意外访问到。第三方代码不会知道新定义的 symbol，因此将 symbol 添加到 `user` 对象是安全的。
	- ### [对象字面量中的 symbol](https://zh.javascript.info/symbol#dui-xiang-zi-mian-liang-zhong-de-symbol) 如果我们要在对象字面量 `{...}` 中使用 symbol，则需要使用方括号把它括起来。
	- ![[Pasted image 20231019145242.png]]
	- 这是因为我们需要变量 `id` 的值作为键，而不是字符串 “id”。
	- [symbol 在 for…in 中会被跳过](https://zh.javascript.info/symbol#symbol-zai-forin-zhong-hui-bei-tiao-guo)
	- [Object.keys(user)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) 也会忽略它们。这是一般“隐藏符号属性”原则的一部分。如果另一个脚本或库遍历我们的对象，它不会意外地访问到符号属性。
	- 相反，[Object.assign](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) 会同时复制字符串和 symbol 属性
	- ## [全局 symbol](https://zh.javascript.info/symbol#quan-ju-symbol)正如我们所看到的，通常所有的 symbol 都是不同的，即使它们有相同的名字。但有时我们想要名字相同的 symbol 具有相同的实体。例如，应用程序的不同部分想要访问的 symbol `"id"` 指的是完全相同的属性。
	- **对于全局 symbol，`Symbol.for(key)` 按名字返回一个 symbol。** 为了实现这一点，这里有一个 **全局 symbol 注册表**。我们可以在其中创建 symbol 并在稍后访问它们，它可以确保每次访问相同名字的 symbol 时，返回的都是相同的 symbol。要从注册表中读取（不存在则创建）symbol，请使用 `Symbol.for(key)`。
		- 该调用会检查全局注册表，如果有一个描述为 `key` 的 symbol，则返回该 symbol，否则将创建一个新 symbol（`Symbol(key)`），并通过给定的 `key` 将其存储在注册表中。
		- ![[Pasted image 20231019145541.png]]
		- 注册表内的 symbol 被称为 **全局 symbol**。如果我们想要一个应用程序范围内的 symbol，可以在代码中随处访问 —— 这就是它们的用途
	- **通过全局 symbol 返回一个名字，我们可以使用 `Symbol.keyFor(sym)`**：
		- `Symbol.keyFor` 内部使用全局 symbol 注册表来查找 symbol 的键。所以它不适用于非全局 symbol。如果 symbol 不是全局的，它将无法找到它并返回 `undefined`。
		- ![[Pasted image 20231019145854.png]]
		- 但是，所有 symbol 都具有 `description` 属性
		- ![[Pasted image 20231019145959.png]]
		- ## [系统 symbol](https://zh.javascript.info/symbol#xi-tong-symbol)
			JavaScript 内部有很多“系统” symbol，我们可以使用它们来微调对象的各个方面。
			它们都被列在了 [众所周知的 symbol](https://tc39.github.io/ecma262/#sec-well-known-symbols) 表的规范中：
			- `Symbol.hasInstance`
			- `Symbol.isConcatSpreadable`
			- `Symbol.iterator`
			- `Symbol.toPrimitive`
			- ……等等。
			例如，`Symbol.toPrimitive` 允许我们将对象描述为原始值转换。我们很快就会看到它的使用。
			当我们研究相应的语言特征时，我们对其他的 symbol 也会慢慢熟悉起来。
82. [ ] #[总结](https://zh.javascript.info/symbol#zong-jie)
		`symbol` 是唯一标识符的基本类型
		symbol 是使用带有可选描述（name）的 `Symbol()` 调用创建的。
		symbol 总是不同的值，即使它们有相同的名字。如果我们希望同名的 symbol 相等，那么我们应该使用全局注册表：`Symbol.for(key)` 返回（如果需要的话则创建）一个以 `key` 作为名字的全局 symbol。使用 `Symbol.for` 多次调用 `key` 相同的 symbol 时，返回的就是同一个 symbol。
		symbol 有两个主要的使用场景：
		1. “隐藏” 对象属性。 
		    如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 symbol 并使用它作为属性的键。symbol 属性不会出现在 `for..in` 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。
		    因此我们可以使用 symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。
		2. JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 `Symbol.*` 访问。我们可以使用它们来改变一些内建行为。例如，在本教程的后面部分，我们将使用 `Symbol.iterator` 来进行 [迭代](https://zh.javascript.info/iterable) 操作，使用 `Symbol.toPrimitive` 来设置 [对象原始值的转换](https://zh.javascript.info/object-toprimitive) 等等。 
		从技术上说，symbol 不是 100% 隐藏的。有一个内建方法 [Object.getOwnPropertySymbols(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols) 允许我们获取所有的 symbol。还有一个名为 [Reflect.ownKeys(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys) 的方法可以返回一个对象的 **所有** 键，包括 symbol。但大多数库、内建方法和语法结构都没有使用这些方法。
83. [ ] #对象 —— 原始值转换 在此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值）。
	1. 没有转换为布尔值。所有的对象在布尔上下文（context）中均为 `true`，就这么简单。只有字符串和数字转换。
	2. 数字转换发生在对象相减或应用数学函数时。例如，`Date` 对象（将在 [日期和时间](https://zh.javascript.info/date) 一章中介绍）可以相减，`date1 - date2` 的结果是两个日期之间的差值。
	3. 至于字符串转换 —— 通常发生在我们像 `alert(obj)` 这样输出一个对象和类似的上下文中。
	4. ## [总结](https://zh.javascript.info/object-toprimitive#zong-jie)
		对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。
		这里有三种类型（hint）：
		- `"string"`（对于 `alert` 和其他需要字符串的操作）
		- `"number"`（对于数学运算）
		- `"default"`（少数运算符，通常对象以和 `"number"` 相同的方式实现 `"default"` 转换）	
		规范明确描述了哪个运算符使用哪个 hint。
		转换算法是：
		1. 调用 `obj[Symbol.toPrimitive](hint)` 如果这个方法存在，
		2. 否则，如果 hint 是 `"string"`
		    - 尝试调用 `obj.toString()` 或 `obj.valueOf()`，无论哪个存在。
		3. 否则，如果 hint 是 `"number"` 或者 `"default"`
		    - 尝试调用 `obj.valueOf()` 或 `obj.toString()`，无论哪个存在。
		所有这些方法都必须返回一个原始值才能工作（如果已定义）。
		在实际使用中，通常只实现 `obj.toString()` 作为字符串转换的“全能”方法就足够了，该方法应该返回对象的“人类可读”表示，用于日志记录或调试。
		
		如果对象被用于与字符串、数字或 symbol 进行 `'=='` 比较，这时到底应该进行哪种转换也不是很明确，因此使用 `"default"` hint。
		像 `<` 和 `>` 这样的小于/大于比较运算符，也可以同时用于字符串和数字。不过，它们使用 “number” hint
		除了一种情况（`Date` 对象，我们稍后会讲到）之外，所有内建对象都以和 `"number"` 相同的方式实现 `"default"` 转换。我们也可以这样做。
1. #原始类型的方法。 
	1. 以下是 `str.toUpperCase()` 中实际发生的情况：
		1. 字符串 `str` 是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有可用的方法，例如 `toUpperCase()`。
		2. 该方法运行并返回一个新的字符串（由 `alert` 显示）。
		3. 特殊对象被销毁，只留下原始值 `str`。
	2. 构造器 `String/Number/Boolean` 仅供内部使用
	3. ![[Pasted image 20231019164529.png]]
	4. 另一方面，调用不带 `new`（关键字）的 `String/Number/Boolean` 函数是可以的且有效的。它们将一个值转换为相应的类型：转成字符串、数字或布尔值（原始类型）。let num = Number("123"); // 将字符串转成数字
	5. null/undefined 没有任何方法，某种意义上说，它们是“最原始的”。
	6. ![[Pasted image 20231019164620.png]]
	7. #[总结](https://zh.javascript.info/primitives-methods#zong-jie)
		- 除 `null` 和 `undefined` 以外的原始类型都提供了许多有用的方法。我们后面的章节中学习这些内容。
		- 从形式上讲，这些方法通过临时对象工作，但 JavaScript 引擎可以很好地调整，以在内部对其进行优化，因此调用它们并不需要太高的成本。
	8. #数字类型 在现代 JavaScript 中，数字（number）有两种类型：
		1. JavaScript 中的常规数字以 64 位的格式 [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754) 存储，也被称为“双精度浮点数”。这是我们大多数时候所使用的数字，我们将在本章中学习它们。
		2. BigInt 用于表示任意长度的整数。有时会需要它们，因为正如我们在前面的章节 [数据类型](https://zh.javascript.info/types) 中提到的，常规整数不能安全地超过 `(253-1)` 或小于 `-(253-1)`。由于仅在少数特殊领域才会用到 BigInt，因此我们在特殊的章节 [BigInt](https://zh.javascript.info/bigint) 中对其进行了介绍。
	9. ## [编写数字的更多方法](https://zh.javascript.info/number#bian-xie-shu-zi-de-geng-duo-fang-fa)
		1. 这里的下划线 `_` 扮演了“[语法糖](https://en.wikipedia.org/wiki/Syntactic_sugar)”的角色，使得数字具有更强的可读性。JavaScript 引擎会直接忽略数字之间的 `_`，所以 上面两个例子其实是一样的。
		2. 在 JavaScript 中，我们可以通过在数字后面附加字母 `"e"` 并指定零的个数来缩短数字：
			1. 换句话说，`e` 把数字乘以 （`1` 后面跟着给定数量的 0 的数字）。![[Pasted image 20231019165527.png]]
			2. 换句话说，`e` 后面的负数表示除以 （1 后面跟着给定数量的 0 的数字）![[Pasted image 20231019165601.png]]
	10. ### [十六进制，二进制和八进制数字](https://zh.javascript.info/number#shi-liu-jin-zhi-er-jin-zhi-he-ba-jin-zhi-shu-zi)****
		1. 数字在 JavaScript 中被广泛用于表示颜色，编码字符以及其他许多东西。所以自然地，有一种较短的写方法：`0x`，然后是数字。![[Pasted image 20231019165703.png]]
		2. 二进制和八进制数字系统很少使用，但也支持使用 `0b` 和 `0o` 前缀![[Pasted image 20231019165716.png]]
		3. 只有这三种进制支持这种写法。对于其他进制，我们应该使用函数 `parseInt`（我们将在本章后面看到）。
	11. ## [toString(base)](https://zh.javascript.info/number#tostringbase)方法 `num.toString(base)` 返回在给定 `base` 进制数字系统中 `num` 的字符串表示形式。![[Pasted image 20231019165921.png]]
		1. `base` 的范围可以从 `2` 到 `36`。默认情况下是 `10`。
		常见的用例如下：
		- **base=16** 用于十六进制颜色，字符编码等，数字可以是 `0..9` 或 `A..F`。
		- **base=2** 主要用于调试按位操作，数字可以是 `0` 或 `1`。 
		- **base=36** 是最大进制，数字可以是 `0..9` 或 `A..Z`。所有拉丁字母都被用于了表示数字。对于 `36` 进制来说，一个有趣且有用的例子是，当我们需要将一个较长的数字标识符转换成较短的时候，例如做一个短的 URL。可以简单地使用基数为 `36` 的数字系统表示：![[Pasted image 20231019165931.png]]
		2. 使用两个点来调用一个方法 ![[Pasted image 20231019170045.png]]
	12.  toFixed调用方式
	13. ![[Pasted image 20231019170308.png]]
	14. ![[Pasted image 20231019170401.png]]
	15. 例如，我们有 `1.2345`，并且想把它舍入到小数点后两位，仅得到 `1.23`。![[Pasted image 20231019170513.png]]
	16. ## [不精确的计算](https://zh.javascript.info/number#bu-jing-que-de-ji-suan)
		1. 在内部，数字是以 64 位格式 [IEEE-754](http://en.wikipedia.org/wiki/IEEE_754) 表示的，所以正好有 64 位可以存储一个数字：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置，而 1 位用于符号。
		2. 如果一个数字真的很大，则可能会溢出 64 位存储，变成一个特殊的数值 `Infinity`![[Pasted image 20231019170740.png]]
		3. 但经常会发生的是，精度的损失。![[Pasted image 20231019170825.png]]
		4. ![[Pasted image 20231019170954.png]]
		5. 我们能解决这个问题吗？当然，最可靠的方法是借助方法 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) 对结果进行舍入![[Pasted image 20231019171220.png]]
		6. 我们可以将数字临时乘以 100（或更大的数字），将其转换为整数，进行数学运算，然后再除回。当我们使用整数进行数学运算时，误差会有所减少，但仍然可以在除法中得到。因此，乘/除法可以减少误差，但不能完全消除误差。![[Pasted image 20231019171213.png]]
		7. ![[Pasted image 20231019171320.png]]
		8. ![[Pasted image 20231019171332.png]]
		9. ## [测试：isFinite 和 isNaN](https://zh.javascript.info/number#ce-shi-isfinite-he-isnan)
			1. 还记得这两个特殊的数值吗？
				- `Infinity`（和 `-Infinity`）是一个特殊的数值，比任何数值都大（小）。
				- `NaN` 代表一个 error。
			2. 它们属于 `number` 类型，但不是“普通”数字，因此，这里有用于检查它们的特殊函数
				1. ![[Pasted image 20231019171532.png]]
				2. ![[Pasted image 20231019171542.png]]
				3. 请注意，在所有数字函数中，包括 `isFinite`，空字符串或仅有空格的字符串均被视为 `0`。![[Pasted image 20231019171717.png]]
		10. ## [parseInt 和 parseFloat](https://zh.javascript.info/number#parseint-he-parsefloat)
			1. 使用加号 `+` 或 `Number()` 的数字转换是严格的。
			2. 如果一个值不完全是一个数字，就会失败唯一的例外是字符串开头或结尾的空格，因为它们会被忽略。
			3. `alert( +"100px" );` // NaN`
			4. 但在现实生活中，我们经常会有带有单位的值，例如 CSS 中的 `"100px"` 或 `"12pt"`。并且，在很多国家，货币符号是紧随金额之后的，所以我们有 `"19€"`，并希望从中提取出一个数值。这就是 `parseInt` 和 `parseFloat` 的作用
			5. 它们可以从字符串中“读取”数字，直到无法读取为止。如果发生 error，则返回收集到的数字。函数 `parseInt` 返回一个整数，而 `parseFloat` 返回一个浮点数
			6. ![[Pasted image 20231019172140.png]]
			7. parseInt(str, radix) 的第二个参数，指定了数字系统的基数，帮助识别数字
			8. ![[Pasted image 20231019172152.png]]
			9. ![[Pasted image 20231019172429.png]]
	17. ## [总结](https://zh.javascript.info/number#zong-jie)
		要写有很多零的数字：
		- 将 `"e"` 和 0 的数量附加到数字后。就像：`123e6` 与 `123` 后面接 6 个 0 相同。
		- `"e"` 后面的负数将使数字除以 1 后面接着给定数量的零的数字。例如 `123e-6` 表示 `0.000123`（`123` 的百万分之一）。
		对于不同的数字系统：
		- 可以直接在十六进制（`0x`），八进制（`0o`）和二进制（`0b`）系统中写入数字。
		- `parseInt(str, base)` 将字符串 `str` 解析为在给定的 `base` 数字系统中的整数，`2 ≤ base ≤ 36`。
		- `num.toString(base)` 将数字转换为在给定的 `base` 数字系统中的字符串。	
		对于常规数字检测：
		- `isNaN(value)` 将其参数转换为数字，然后检测它是否为 `NaN`
		- `isFinite(value)` 将其参数转换为数字，如果它是常规数字，则返回 `true`，而不是 `NaN/Infinity/-Infinity`
		要将 `12pt` 和 `100px` 之类的值转换为数字：
		- 使用 `parseInt/parseFloat` 进行“软”转换，它从字符串中读取数字，然后返回在发生 error 前可以读取到的值。
		小数：
		- 使用 `Math.floor`，`Math.ceil`，`Math.trunc`，`Math.round` 或 `num.toFixed(precision)` 进行舍入。
		- 请确保记住使用小数时会损失精度。
		更多数学函数：
		- 需要时请查看 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) 对象。这个库很小，但是可以满足基本的需求。
85. [ ]  字符串
	1. [特殊字符](https://zh.javascript.info/string#te-shu-zi-fu)
	2. ![[Pasted image 20231020141010.png]]
	3. [访问字符](https://zh.javascript.info/string#fang-wen-zi-fu)  要获取在 `pos` 位置的一个字符，可以使用方括号 `[pos]` 或者调用 [str.charAt(pos)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/charAt) 方法。第一个字符从零位置开始
	4. [字符串是不可变的](https://zh.javascript.info/string#zi-fu-chuan-shi-bu-ke-bian-de) 在 JavaScript 中，字符串不可更改。改变字符是不可能的。通常的解决方法是创建一个新的字符串，并将其分配给 `str` 而不是以前的字符串。
	5. [改变大小写](https://zh.javascript.info/string#gai-bian-da-xiao-xie)[toLowerCase()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase) 和 [toUpperCase()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase) 方法可以改变大小写
	6. [查找子字符串](https://zh.javascript.info/string#cha-zhao-zi-zi-fu-chuan) 
		1. [str.indexOf](https://zh.javascript.info/string#strindexof) :第一个方法是 [str.indexOf(substr, pos)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf)。它从给定位置 `pos` 开始，在 `str` 中查找 `substr`，如果没有找到，则返回 `-1`，否则返回匹配成功的位置。
		2. [按位（bitwise）NOT 技巧](https://zh.javascript.info/string#an-wei-bitwisenot-ji-qiao)这里使用的一个老技巧是 [bitwise NOT](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT) `~` 运算符。它将数字转换为 32-bit 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反。只要记住：`if (~str.indexOf(...))` 读作 “if found”。
		3. [includes，startsWith，endsWith](https://zh.javascript.info/string#includesstartswithendswith)更现代的方法 [str.includes(substr, pos)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/includes) 根据 `str` 中是否包含 `substr` 来返回 `true/false`。如果我们需要检测匹配，但不需要它的位置，那么这是正确的选择.
		4. [获取子字符串](https://zh.javascript.info/string#huo-qu-zi-zi-fu-chuan) JavaScript 中有三种获取字符串的方法：`substring`、`substr` 和 `slice`。![[Pasted image 20231020141856.png]]
		5. [比较字符串](https://zh.javascript.info/string#bi-jiao-zi-fu-chuan)正如我们从 [值的比较](https://zh.javascript.info/comparison) 一章中了解到的，字符串按字母顺序逐字比较:不过，也有一些奇怪的地方。
			1. 小写字母总是大于大写字母：
			2. 带变音符号的字母存在“乱序”的情况
			3. 在 JavaScript 中字符串的内部表示。所有的字符串都使用 [UTF-16](https://en.wikipedia.org/wiki/UTF-16) 编码。即：每个字符都有对应的数字代码。有特殊的方法可以获取代码表示的字符，以及字符对应的代码。
			4. `str.codePointAt(pos)`返回在 `pos` 位置的字符代码
			5. `String.fromCodePoint(code)`  通过数字 `code` 创建字符
			6. 我们还可以用 `\u` 后跟十六进制代码，通过这些代码添加 Unicode 字符
			7. ![[Pasted image 20231020142408.png]]
			8. 现在很明显为什么 `a > Z`。
				字符通过数字代码进行比较。越大的代码意味着字符越大。`a`（97）的代码大于 `Z`（90）的代码。
				
				- 所有小写字母追随在大写字母之后，因为它们的代码更大。
				- 一些像 `Ö` 的字母与主要字母表不同。这里，它的代码比任何从 `a` 到 `z` 的代码都要大。
			9. [正确的比较](https://zh.javascript.info/string#%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%AF%94%E8%BE%83) 国际化标准 [ECMA-402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf)。
				它提供了一种特殊的方法来比较不同语言的字符串，遵循它们的规则。
				调用 [str.localeCompare(str2)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare) 会根据语言规则返回一个整数，这个整数能指示字符串 `str` 在排序顺序中排在字符串 `str2` 前面、后面、还是相同
				- 如果 `str` 排在 `str2` 前面，则返回负数。
				- 如果 `str` 排在 `str2` 后面，则返回正数。
				- 如果它们在相同位置，则返回 `0`。![[Pasted image 20231020142712.png]]
				- ### [代理对](https://zh.javascript.info/string#dai-li-dui) 所有常用的字符都是一个 2 字节的代码。大多数欧洲语言，数字甚至大多数象形文字中的字母都有 2 字节的表示形式。但 2 字节只允许 65536 个组合，这对于表示每个可能的符号是不够的。所以稀有的符号被称为“代理对”的一对 2 字节的符号编码。
					- 注意，代理对在 JavaScript 被创建时并不存在，因此无法被编程语言正确处理！我们实际上在上面的每个字符串中都有一个符号，但 `length` 显示长度为 `2`。
					- `String.fromCodePoint` 和 `str.codePointAt` 是几种处理代理对的少数方法。它们最近才出现在编程语言中。
					- 在它们之前，只有 [String.fromCharCode](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode) 和 [str.charCodeAt](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt)。这些方法实际上与 `fromCodePoint/codePointAt` 相同，但是不适用于代理对。
					- 技术角度来说，代理对也是可以通过它们的代码检测到的：如果一个字符的代码在 `0xd800..0xdbff` 范围内，那么它是代理对的第一部分。下一个字符（第二部分）必须在 `0xdc00..0xdfff` 范围中。这些范围是按照标准专门为代理对保留的。
				- ### [变音符号与规范化](https://zh.javascript.info/string#bian-yin-fu-hao-yu-gui-fan-hua)在许多语言中，都有一些由基本字符组成的符号，在其上方/下方有一个标记。例如，字母 `a` 可以是 `àáâäãåā` 的基本字符。最常见的“复合”字符在 UTF-16 表中都有自己的代码。但不是全部，因为可能的组合太多。为了支持任意组合，UTF-16 允许我们使用多个 Unicode 字符：基本字符紧跟“装饰”它的一个或多个“标记”字符。
					- 例如，如果我们 `S` 后跟有特殊的 “dot above” 字符（代码 `\u0307`），则显示 Ṡ。
					- 如果我们需要在字母上方（或下方）添加额外的标记 —— 没问题，只需要添加必要的标记字符即可。例如，如果我们追加一个字符 “dot below”（代码 `\u0323`），那么我们将得到“S 上面和下面都有点”的字符：`Ṩ`。
					- 这在提供良好灵活性的同时，也存在一个有趣的问题：两个视觉上看起来相同的字符，可以用不同的 Unicode 组合表示。
					- 为了解决这个问题，有一个 “Unicode 规范化”算法，它将每个字符串都转化成单个“通用”格式。它由 [str.normalize()](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/normalize) 实现。
					- 事实上，情况并非总是如此，因为符号 `Ṩ` 是“常用”的，所以 UTF-16 创建者把它包含在主表中并给它了对应的代码。如果你想了解更多关于规范化规则和变体的信息 —— 它们在 Unicode 标准附录中有详细描述：[Unicode 规范化形式](http://www.unicode.org/reports/tr15/)，但对于大多数实际目的来说，本文的内容就已经足够了。
			10. ## [总结](https://zh.javascript.info/string#zong-jie)
				- 有 3 种类型的引号。反引号允许字符串跨越多行并可以使用 `${…}` 在字符串中嵌入表达式。
				- JavaScript 中的字符串使用的是 UTF-16 编码。
				- 我们可以使用像 `\n` 这样的特殊字符或通过使用 `\u...` 来操作它们的 Unicode 进行字符插入。
				- 获取字符时，使用 `[]`。
				- 获取子字符串，使用 `slice` 或 `substring`。
				- 字符串的大/小写转换，使用：`toLowerCase/toUpperCase`。
				- 查找子字符串时，使用 `indexOf` 或 `includes/startsWith/endsWith` 进行简单检查。
				- 根据语言比较字符串时使用 `localeCompare`，否则将按字符代码进行比较。
				还有其他几种有用的字符串方法：
				- `str.trim()` —— 删除字符串前后的空格 (“trims”)。
				- `str.repeat(n)` —— 重复字符串 `n` 次。
				- ……更多内容细节请参见 [手册](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String)。
				字符串还具有使用正则表达式进行搜索/替换的方法。但这个话题很大，因此我们将在本教程中单独的 [正则表达式](https://zh.javascript.info/regular-expressions) 章节中进行讨论。
86. 数组
	1. [使用 “at” 获取最后一个元素](https://zh.javascript.info/array#shi-yong-at-huo-qu-zui-hou-yi-ge-yuan-su)幸运的是，这里有一个更简短的语法 `fruits.at(-1)`
	2. [pop/push, shift/unshift 方法](https://zh.javascript.info/array#poppushshiftunshift-fang-fa)
		1. 栈：LIFO（Last-In-First-Out），即后进先出法则。![[Pasted image 20231020145232.png]]
		2. 队列： FIFO（First-In-First-Out），即先进先出。![[Pasted image 20231020145310.png]]
		3. JavaScript 中的数组既可以用作队列，也可以用作栈。它们允许你从首端/末端来添加/删除元素。这在计算机科学中，允许这样的操作的数据结构被称为 [双端队列（deque）](https://en.wikipedia.org/wiki/Double-ended_queue)。
		4. 数组是一种特殊的对象。使用方括号来访问属性 `arr[0]` 实际上是来自于对象的语法。它其实与 `obj[key]` 相同，其中 `arr` 是对象，而数字用作键（key）。它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及 `length` 属性。但从本质上讲，它仍然是一个对象。记住，在 JavaScript 中只有 8 种基本的数据类型（详见 [数据类型](https://zh.javascript.info/types) 一章）。数组是一个对象，因此其行为也像一个对象。
		5. 是数组真正特殊的是它们的内部实现。JavaScript 引擎尝试把这些元素一个接一个地存储在连续的内存区域，就像本章的插图显示的一样，而且还有一些其它的优化，以使数组运行得非常快。但是，如果我们不像“有序集合”那样使用数组，而是像常规对象那样使用数组，这些就都不生效了。
		6. 这是可以的，因为数组是基于对象的。我们可以给它们添加任何属性。
			但是 Javascript 引擎会发现，我们在像使用常规对象一样使用数组，那么针对数组的优化就不再适用了，然后对应的优化就会被关闭，这些优化所带来的优势也就荡然无存了。
			数组误用的几种方式:
			- 添加一个非数字的属性，比如 `arr.test = 5`。
			- 制造空洞，比如：添加 `arr[0]`，然后添加 `arr[1000]` (它们中间什么都没有)。
			- 以倒序填充数组，比如 `arr[1000]`，`arr[999]` 等等。
			请将数组视为作用于 **有序数据** 的特殊结构。它们为此提供了特殊的方法。数组在 JavaScript 引擎内部是经过特殊调整的，使得更好地作用于连续的有序数据，所以请以正确的方式使用数组。如果你需要任意键值，那很有可能实际上你需要的是常规对象 `{}`。
		7. ## [循环](https://zh.javascript.info/array#xun-huan)
			1. 遍历数组最古老的方式就是 `for` 循环：
			2. 但对于数组来说还有另一种循环方式，`for..of`：`for..of` 不能获取当前元素的索引，只是获取元素值，但大多数情况是够用的。而且这样写更短。
			3. 技术上来讲，因为数组也是对象，所以使用 `for..in` 也是可以的：但这其实是一个很不好的想法。会有一些潜在问题存在：
				1. `for..in` 循环会遍历 **所有属性**，不仅仅是这些数字属性。
				    在浏览器和其它环境中有一种称为“类数组”的对象，它们 **看似是数组**。也就是说，它们有 `length` 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。`for..in` 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。
				2. `for..in` 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。当然即使是这样也依然非常快。只有在遇到瓶颈时可能会有问题。但是我们仍然应该了解这其中的不同。
				3. 通常来说，我们不应该用 `for..in` 来处理数组。
		8. ## [关于 “length”](https://zh.javascript.info/array#guan-yu-length)当我们修改数组的时候，`length` 属性会自动更新。准确来说，它实际上不是数组里元素的个数，而是最大的数字索引值加一。 `length` 属性的另一个有意思的点是它是可写的。如果我们手动增加它，则不会发生任何有趣的事儿。但是如果我们减少它，数组就会被截断。该过程是不可逆的.所以，清空数组最简单的方法就是：`arr.length = 0;`。
		9. ## [new Array()](https://zh.javascript.info/array#new-array)这是创建数组的另一种语法,它很少被使用，因为方括号 `[]` 更短更简洁。而且，这种语法还有一个棘手的特性。如果使用单个参数（即数字）调用 `new Array`，那么它会创建一个 **指定了长度，却没有任何项** 的数组。
		10. ## [多维数组](https://zh.javascript.info/array#duo-wei-shu-zu)数组里的项也可以是数组。我们可以将其用于多维数组，例如存储矩阵
		11. ## [toString](https://zh.javascript.info/array#tostring)数组有自己的 `toString` 方法的实现，会返回以逗号隔开的元素列表。数组没有 `Symbol.toPrimitive`，也没有 `valueOf`，它们只能执行 `toString` 进行转换，所以这里 `[]` 就变成了一个空字符串，`[1]` 变成了 `"1"`，`[1,2]` 变成了 `"1,2"`。
		12. ## [不要使用 == 比较数组](https://zh.javascript.info/array#bu-yao-shi-yong-bi-jiao-shu-zu)JavaScript 中的数组与其它一些编程语言的不同，不应该使用 `'=='` 运算符比较 JavaScript 中的数组。该运算符不会对数组进行特殊处理，它会像处理任意对象那样处理数组。让我们回顾一下规则：
			- 仅当两个对象引用的是同一个对象时，它们才相等 `'=='`。
			- 如果 `'=='` 左右两个参数之中有一个参数是对象，另一个参数是原始类型，那么该对象将会被转换为原始类型，转换规则如 [对象 —— 原始值转换](https://zh.javascript.info/object-toprimitive) 一章所述。
			- ……`null` 和 `undefined` 相等 `'=='`，且各自不等于任何其他的值。
		13. ## [总结](https://zh.javascript.info/array#zong-jie)
			数组是一种特殊的对象，适用于存储和管理有序的数据项。
			![[Pasted image 20231020151326.png]]
			调用 `new Array(number)` 会创建一个给定长度的数组，但不含有任何项。
			- `length` 属性是数组的长度，准确地说，它是数组最后一个数字索引值加一。它由数组方法自动调整。
			- 如果我们手动缩短 `length`，那么数组就会被截断。
			获取元素：
			- 你可以通过元素的索引获取元素，例如 `arr[0]`
			- 我们也可以使用允许负索引的 `at(i)` 方法。对于负值的 `i`，它会从数组的末尾往回数。如果 `i >= 0`，它的工作方式与 `arr[i]` 相同。
			我们可以通过下列操作以双端队列的方式使用数组：
			- `push(...items)` 在末端添加 `items` 项。
			- `pop()` 从末端移除并返回该元素。
			- `shift()` 从首端移除并返回该元素。
			- `unshift(...items)` 从首端添加 `items` 项。
			遍历数组的元素：
			- `for (let i=0; i<arr.length; i++)` — 运行得最快，可兼容旧版本浏览器。
			- `for (let item of arr)` — 现代语法，只能访问 items。
			- `for (let i in arr)` — 永远不要用这个。
			比较数组时，不要使用 `'=='` 运算符（当然也不要使用 `>` 和 `<` 等运算符），因为它们不会对数组进行特殊处理。它们通常会像处理任意对象那样处理数组，这通常不是我们想要的。
			但是，我们可以使用 `for..of` 循环来逐项比较数组。
			在下一章 [数组方法](https://zh.javascript.info/array-methods) 中，我们将继续学习数组，学习更多添加、移除、提取元素和数组排序的方法。
			## [不同类型间的比较](https://zh.javascript.info/comparison#bu-tong-lei-xing-jian-de-bi-jiao)当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小。
			## [null 和 undefined](https://zh.javascript.info/comparison#dui-null-he-undefined-jin-hang-bi-jiao)
				JavaScript 存在一个特殊的规则，会判定它们相等。它们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值（只在非严格相等下成立）。
				当使用数学式或其他比较方法 `< > <= >=` 时：`null/undefined` 会被转化为数字：`null` 被转化为 `0`，`undefined` 被转化为 `NaN`。
				这是因为相等性检查 `'=='` 和普通比较符 `> < >= <=` 的代码逻辑是相互独立的。进行值的比较时，`null` 会被转化为数字，因此它被转化为了 `0`。
				另一方面，`undefined` 和 `null` 在相等性检查 `'=='` 中不会进行任何的类型转换，它们有自己独立的比较规则，
85. [ ] 数组方法
	1. sort方法： **这些元素默认情况下被按字符串进行排序。**
		1. 要使用我们自己的排序顺序，我们需要提供一个函数作为 `arr.sort()` 的参数。
		2. 该函数应该比较两个任意值并返回
		3. `arr` 可以是由任何内容组成的数组，对吗？它可能包含数字、字符串、对象或其他任何内容。我们有一组 **一些元素**。要对其进行排序，我们需要一个 **排序函数** 来确认如何比较这些元素。默认是按字符串进行排序的。
		4. `arr.sort(fn)` 方法实现了通用的排序算法。我们不需要关心它的内部工作原理（大多数情况下都是经过 [快速排序](https://en.wikipedia.org/wiki/Quicksort) 或 [Timsort](https://en.wikipedia.org/wiki/Timsort) 算法优化的）。它将遍历数组，使用提供的函数比较其元素并对其重新排序，我们所需要的就是提供执行比较的函数 `fn`。
	2. [str.split(delim)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/split) delim：网络	定界；分隔符；**默认为逗号**
	3. [arr.join(glue)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/join) glue：胶水
	4. [reduce/reduceRight](https://zh.javascript.info/array-methods#reducereduceright)
		1. 当我们需要遍历一个数组时 —— 我们可以使用 `forEach`，`for` 或 `for..of`。
		2. 当我们需要遍历并返回每个元素的数据时 —— 我们可以使用 `map`。
		3. [arr.reduce](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)语法是： 
		```js
		let value = arr.reduce(function  (accumulator, item, index, array){
			// ...
		}, [initial]);
			```
	    4.  该函数一个接一个地应用于所有数组元素，并将其结果“搬运（carry on）”到下一个调用。
			参数：
			- `accumulator` —— 是上一个函数调用的结果，第一次等于 `initial`（如果提供了 `initial` 的话）。
			- `item` —— 当前的数组元素。
			- `index` —— 当前索引。
			- `arr` —— 数组本身。
			应用函数时，上一个函数调用的结果将作为第一个参数传递给下一个函数。
			因此，第一个参数本质上是累加器，用于存储所有先前执行的组合结果。最后，它成为 `reduce` 的结果。
			如果在上面的示例中我们使用了 `users.filter(army.canJoin)`，那么 `army.canJoin` 将被作为独立函数调用，并且这时 `this=undefined`，从而会导致即时错误。
	![[Pasted image 20231023141829.png]]
			可以用 `users.filter(user => army.canJoin(user))` 替换对 `users.filter(army.canJoin, army)` 的调用。前者的使用频率更高，因为对于大多数人来说，它更容易理解。
			## [总结](https://zh.javascript.info/array-methods#zong-jie)
		数组方法备忘单：
		- 添加/删除元素： 
		    - `push(...items)` —— 向尾端添加元素，
		    - `pop()` —— 从尾端提取一个元素，
		    - `shift()` —— 从首端提取一个元素，
		    - `unshift(...items)` —— 向首端添加元素，
		    - `splice(pos, deleteCount, ...items)` —— 从 `pos` 开始删除 `deleteCount` 个元素，并插入 `items`。
		    - `slice(start, end)` —— 创建一个新数组，将从索引 `start` 到索引 `end`（但不包括 `end`）的元素复制进去。
		    - `concat(...items)` —— 返回一个新数组：复制当前数组的所有元素，并向其中添加 `items`。如果 `items` 中的任意一项是一个数组，那么就取其元素。
		- 搜索元素：
		    - `indexOf/lastIndexOf(item, pos)` —— 从索引 `pos` 开始搜索 `item`，搜索到则返回该项的索引，否则返回 `-1`。
		    - `includes(value)` —— 如果数组有 `value`，则返回 `true`，否则返回 `false`。
		    - `find/filter(func)` —— 通过 `func` 过滤元素，返回使 `func` 返回 `true` 的第一个值/所有值。
		    - `findIndex` 和 `find` 类似，但返回索引而不是值。
		- 遍历元素：
		    - `forEach(func)` —— 对每个元素都调用 `func`，不返回任何内容。
		- 转换数组：
		    - `map(func)` —— 根据对每个元素调用 `func` 的结果创建一个新数组。
		    - `sort(func)` —— 对数组进行原位（in-place）排序，然后返回它。
		    - `reverse()` —— 原位（in-place）反转数组，然后返回它。
		    - `split/join` —— 将字符串转换为数组并返回。
		    - `reduce/reduceRight(func, initial)` —— 通过对每个元素调用 `func` 计算数组上的单个值，并在调用之间传递中间结果。
		- 其他：
		    - `Array.isArray(value)` 检查 `value` 是否是一个数组，如果是则返回 `true`，否则返回 `false`。
		请注意，`sort`，`reverse` 和 `splice` 方法修改的是数组本身。
		这些是最常用的方法，它们覆盖 99％ 的用例。但是还有其他几个：
		- [arr.some(fn)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/some)/[arr.every(fn)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/every) 检查数组。
		    与 `map` 类似，对数组的每个元素调用函数 `fn`。如果任何/所有结果为 `true`，则返回 `true`，否则返回 `false`。
		    这两个方法的行为类似于 `||` 和 `&&` 运算符：如果 `fn` 返回一个真值，`arr.some()` 立即返回 `true` 并停止迭代其余数组项；如果 `fn` 返回一个假值，`arr.every()` 立即返回 `false` 并停止对其余数组项的迭代。
		    我们可以使用 `every` 来比较数组：
		   ![[Pasted image 20231023142150.png]]
		    
		- [arr.fill(value, start, end)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/fill) —— 从索引 `start` 到 `end`，用重复的 `value` 填充数组。 
		- [arr.copyWithin(target, start, end)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin) —— 将从位置 `start` 到 `end` 的所有元素复制到 **自身** 的 `target` 位置（覆盖现有元素）。 
		- [arr.flat(depth)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)/[arr.flatMap(fn)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap) 从多维数组创建一个新的扁平数组。 
		- [Array.of(element0[, element1[, …[, elementN]]])](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/of) 基于可变数量的参数创建一个新的 `Array` 实例，而不需要考虑参数的数量或类型。
		有关完整列表，请参阅 [手册](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array)。
		乍看起来，似乎有很多方法，很难记住。但实际上这比看起来要容易得多。
		浏览这个备忘单，以了解这些方法。然后解决本章中的习题来进行练习，以便让你有数组方法的使用经验。
		然后，每当你需要对数组进行某些操作，而又不知道怎么做的时候，请回到这儿，查看这个备忘单，然后找到正确的方法。示例将帮助你正确编写它。用不了多久，你就自然而然地记住这些方法了，根本不需要你死记硬背。
		* 与 `str.split` 方法不同，它依赖于字符串的可迭代特性。因此，就像 `for..of` 一样，可以正确地处理代理对（surrogate pair）。（译注：代理对也就是 UTF-16 扩展字符。）
		* 我们甚至可以基于 `Array.from` 创建代理感知（surrogate-aware）的`slice` 方法（译注：也就是能够处理 UTF-16 扩展字符的 `slice` 方法）：![[Pasted image 20231023150905.png]]
		* 可以应用 `for..of` 的对象被称为 **可迭代的**。
			- 技术上来说，可迭代对象必须实现 `Symbol.iterator` 方法。
			    - `obj[Symbol.iterator]()` 的结果被称为 **迭代器（iterator）**。由它处理进一步的迭代过程。
			    - 一个迭代器必须有 `next()` 方法，它返回一个 `{done: Boolean, value: any}` 对象，这里 `done:true` 表明迭代结束，否则 `value` 就是下一个值。
			- `Symbol.iterator` 方法会被 `for..of` 自动调用，但我们也可以直接调用它。
			- 内建的可迭代对象例如字符串和数组，都实现了 `Symbol.iterator`。
			- 字符串迭代器能够识别代理对（surrogate pair）。（译注：代理对也就是 UTF-16 扩展字符。）
			有索引属性和 `length` 属性的对象被称为 **类数组对象**。这种对象可能还具有其他属性和方法，但是没有数组的内建方法。
			如果我们仔细研究一下规范 —— 就会发现大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是“真正的”数组，因为这样抽象度更高。
			`Array.from(obj[, mapFn, thisArg])` 将可迭代对象或类数组对象 `obj` 转化为真正的数组 `Array`，然后我们就可以对它应用数组的方法。可选参数 `mapFn` 和 `thisArg` 允许我们将函数应用到每个元素。
86. [ ] `WeakMap` 是类似于 `Map` 的集合，它仅允许对象作为键，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象与其关联值一同删除。
		`WeakSet` 是类似于 `Set` 的集合，它仅存储对象，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象删除。
		它们的主要优点是它们对对象是弱引用，所以被它们引用的对象很容易地被垃圾收集器移除。
		这是以不支持 `clear`、`size`、`keys`、`values` 等作为代价换来的……
		`WeakMap` 和 `WeakSet` 被用作“主要”对象存储之外的“辅助”数据结构。一旦将对象从主存储器中删除，如果该对象仅被用作 `WeakMap` 或 `WeakSet` 的键，那么该对象将被自动清除。
87. [ ] ## [转换对象](https://zh.javascript.info/keys-values-entries#zhuan-huan-dui-xiang)
	对象缺少数组存在的许多方法，例如 `map` 和 `filter` 等。
	如果我们想应用它们，那么我们可以使用 `Object.entries`，然后使用 `Object.fromEntries`：
	1. 使用 `Object.entries(obj)` 从 `obj` 获取由键/值对组成的数组。
	2. 对该数组使用数组方法，例如 `map`，对这些键/值对进行转换。
	3. 对结果数组使用 `Object.fromEntries(array)` 方法，将结果转回成对象。
88. [ ] # 解构赋值
	1. ## [数组解构](https://zh.javascript.info/destructuring-assignment#shu-zu-jie-gou)
	2. ### [其余的 ‘…’](https://zh.javascript.info/destructuring-assignment#qi-yu-de)
	3. ## [对象解构](https://zh.javascript.info/destructuring-assignment#dui-xiang-jie-gou)
	4. ### [剩余模式（pattern）"…"](https://zh.javascript.info/destructuring-assignment#sheng-yu-mo-shi-pattern)
	5. ## [智能函数参数](https://zh.javascript.info/destructuring-assignment#zhi-neng-han-shu-can-shu)
	6. ![[Pasted image 20231023163651.png]]
89. [ ] ## [总结](https://zh.javascript.info/date#zong-jie)
	- 在 JavaScript 中，日期和时间使用 [Date](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date) 对象来表示。我们不能单独创建日期或时间，`Date` 对象总是同时创建两者。
	- 月份从 0 开始计数（对，一月是 0）。
	- 一周中的某一天 `getDay()` 同样从 0 开始计算（0 代表星期日）。
	- 当设置了超出范围的组件时，`Date` 会进行自动校准。这一点对于日/月/小时的加减很有用。
	- 日期可以相减，得到的是以毫秒表示的两者的差值。因为当 `Date` 被转换为数字时，`Date` 对象会被转换为时间戳。
	- 使用 `Date.now()` 可以更快地获取当前时间的时间戳。
	和其他系统不同，JavaScript 中时间戳以毫秒为单位，而不是秒。
	有时我们需要更加精准的时间度量。JavaScript 自身并没有测量微秒的方法（百万分之一秒），但大多数运行环境会提供。例如：浏览器有 [performance.now()](https://developer.mozilla.org/zh/docs/Web/API/Performance/now) 方法来给出从页面加载开始的以毫秒为单位的微秒数（精确到毫秒的小数点后三位）：![[Pasted image 20231023170640.png]]
90. [ ] # JSON 方法，toJSON
	1. 重要的限制：不得有循环引用。
	2. - JSON 是一种数据格式，具有自己的独立标准和大多数编程语言的库。
		- JSON 支持 object，array，string，number，boolean 和 `null`。
		- JavaScript 提供序列化（serialize）成 JSON 的方法 [JSON.stringify](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) 和解析 JSON 的方法 [JSON.parse](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)。
		- 这两种方法都支持用于智能读/写的转换函数。
		- 如果一个对象具有 `toJSON`，那么它会被 `JSON.stringify` 调用。
91. [ ] ![[Pasted image 20231024093632.png]]
92. [ ] 我们已经知道，箭头函数没有自身的 `this`。现在我们知道了它们也没有特殊的 `arguments` 对象。 
	 [总结](https://zh.javascript.info/rest-parameters-spread#zong-jie)
	当我们在代码中看到 `"..."` 时，它要么是 rest 参数，要么是 spread 语法。
	有一个简单的方法可以区分它们：
	- 若 `...` 出现在函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中剩余的参数收集到一个数组中。
	- 若 `...` 出现在函数调用或类似的表达式中，那它就是 spread 语法，它会把一个数组展开为列表。
	使用场景：
	- Rest 参数用于创建可接受任意数量参数的函数。
	- Spread 语法用于将数组传递给通常需要含有许多参数的函数。
	我们可以使用这两种语法轻松地互相转换列表与参数数组。
	旧式的 `arguments`（类数组且可迭代的对象）也依然能够帮助我们获取函数调用中的所有参数。
93. [ ] 变量作用域，闭包
	1. 从视觉上看，`let i` 位于 `{...}` 之外。但是 `for` 构造在这里很特殊：在其中声明的变量被视为块的一部分。![[Pasted image 20231024105539.png]]
	2. [实际开发中的优化](https://zh.javascript.info/closure#shi-ji-kai-fa-zhong-de-you-hua)正如我们所看到的，理论上当函数可达时，它外部的所有变量也都将存在。但在实际中，JavaScript 引擎会试图优化它。它们会分析变量的使用情况，如果从代码中可以明显看出有未使用的外部变量，那么就会将其删除。
94. [ ] 全局对象
		1. ## [总结](https://zh.javascript.info/global-object#zong-jie)
	- 全局对象包含应该在任何位置都可见的变量。
	    其中包括 JavaScript 的内建方法，例如 “Array” 和环境特定（environment-specific）的值，例如 `window.innerHeight` — 浏览器中的窗口高度。
	- 全局对象有一个通用名称 `globalThis`。
	    ……但是更常见的是使用“老式”的环境特定（environment-specific）的名字，例如 `window`（浏览器）和 `global`（Node.js）。
	- 仅当值对于我们的项目而言确实是全局的时候，才应将其存储在全局对象中。并保持其数量最少。
	- 在浏览器中，除非我们使用 [modules](https://zh.javascript.info/modules)，否则使用 `var` 声明的全局函数和变量会成为全局对象的属性。    
	- 为了使我们的代码面向未来并更易于理解，我们应该使用直接的方式访问全局对象的属性，如 `window.x`。
95. [ ] 函数的类型是对象。
	我们介绍了它们的一些属性：	
	- `name` —— 函数的名字。通常取自函数定义，但如果函数定义时没设定函数名，JavaScript 会尝试通过函数的上下文猜一个函数名（例如把赋值的变量名取为函数名）。
	- `length` —— 函数定义时的入参的个数。Rest 参数不参与计数。
	如果函数是通过函数表达式的形式被声明的（不是在主代码流里），并且附带了名字，那么它被称为命名函数表达式（Named Function Expression）。这个名字可以用于在该函数内部进行自调用，例如递归调用等。
	此外，函数可以带有额外的属性。很多知名的 JavaScript 库都充分利用了这个功能。
	它们创建一个“主”函数，然后给它附加很多其它“辅助”函数。例如，[jQuery](https://jquery.com/) 库创建了一个名为 `$` 的函数。[lodash](https://lodash.com/) 库创建一个 `_` 函数，然后为其添加了 `_.add`、`_.keyBy` 以及其它属性（想要了解更多内容，参查阅 [docs](https://lodash.com/docs)）。实际上，它们这么做是为了减少对全局空间的污染，这样一个库就只会有一个全局变量。这样就降低了命名冲突的可能性。
	所以，一个函数本身可以完成一项有用的工作，还可以在自身的属性中附带许多其他功能。
96. [ ] # "new Function" 语法
	通常，闭包是指使用一个特殊的属性 `[[Environment]]` 来记录函数自身的创建时的环境的函数。它具体指向了函数创建时的词法环境。（我们在 [变量作用域，闭包](https://zh.javascript.info/closure) 一章中对此进行了详细的讲解）。
	但是如果我们使用 `new Function` 创建一个函数，那么该函数的 `[[Environment]]` 并不指向当前的词法环境，而是指向全局环境。
	因此，此类函数无法访问外部（outer）变量，只能访问全局变量。![[Pasted image 20231024112345.png]]
97. [ ] # 调度：setTimeout 和 setInterval ## [总结](https://zh.javascript.info/settimeout-setinterval#zong-jie)
	- `setTimeout(func, delay, ...args)` 和 `setInterval(func, delay, ...args)` 方法允许我们在 `delay` 毫秒之后运行 `func` 一次或以 `delay` 毫秒为时间间隔周期性运行 `func`。
	- 要取消函数的执行，我们应该调用 `clearInterval/clearTimeout`，并将 `setInterval/setTimeout` 返回的值作为入参传入。
	- 嵌套的 `setTimeout` 比 `setInterval` 用起来更加灵活，允许我们更精确地设置两次执行之间的时间。
	- 零延时调度 `setTimeout(func, 0)`（与 `setTimeout(func)` 相同）用来调度需要尽快执行的调用，但是会在当前脚本执行完成后进行调用。
	- 浏览器会将 `setTimeout` 或 `setInterval` 的五层或更多层嵌套调用（调用五次之后）的最小延时限制在 4ms。这是历史遗留问题。
	请注意，所有的调度方法都不能 **保证** 确切的延时。
	例如，浏览器内的计时器可能由于许多原因而变慢：
	- CPU 过载。
	- 浏览器页签处于后台模式。
	- 笔记本电脑用的是省电模式。
	所有这些因素，可能会将定时器的最小计时器分辨率（最小延迟）增加到 300ms 甚至 1000ms，具体以浏览器及其设置为准。
98. [ ] # 装饰器模式和转发，call/apply![[Pasted image 20231024151746.png]]
	1. debounce防抖装饰器![[Pasted image 20231024153109.png]]
	2. throttle节流装饰器![[Pasted image 20231024153159.png]]
		1. 调用 `throttle(func, ms)` 返回 `wrapper`。
			1. 在第一次调用期间，`wrapper` 只运行 `func` 并设置冷却状态（`isThrottled = true`）。
			2. 在冷却状态下，所有调用都被保存在 `savedArgs/savedThis` 中。请注意，上下文（this）和参数（arguments）都很重要，应该被保存下来。我们需要它们来重现调用。
			3. 经过 `ms` 毫秒后，`setTimeout`中的函数被触发。冷却状态被移除（`isThrottled = false`），如果存在被忽略的调用，将使用最后一次调用保存的参数和上下文运行 `wrapper`。
			第 3 步运行的不是 `func`，而是 `wrapper`，因为我们不仅需要执行 `func`，还需要再次进入冷却状态并设置 `setTimeout` 以重置节流。
			- `debounce` 会在“冷却（cooldown）”期后运行函数一次。适用于处理最终结果。
			- `throttle` 运行函数的频率不会大于所给定的时间 `ms` 毫秒。适用于不应该经常进行的定期更新。
	1. 延时装饰器![[Pasted image 20231024153302.png]]
	2. 间谍装饰器![[Pasted image 20231024153322.png]]
99. [ ] # 函数绑定 ## [总结](https://zh.javascript.info/bind#zong-jie)
	方法 `func.bind(context, ...args)` 返回函数 `func` 的“绑定的（bound）变体”，它绑定了上下文 `this` 和 `...args` 参数。
	通常我们应用 `bind` 来绑定对象方法的 `this`，这样我们就可以把它们传递到其他地方使用。例如，传递给 `setTimeout`。
	当我们绑定一个现有的函数的某些参数时，绑定后的（不太通用的）函数被称为 **partially applied** 或 **partial**。
	当我们不想一遍又一遍地重复相同的参数时，部分应用函数非常有用。就像我们有一个 `send(from, to)` 函数，并且对于我们的任务来说，`from` 应该总是一样的，那么我们就可以使用它的一个部分应用函数。
100. [ ] 箭头函数 
	1. ## [箭头函数没有 “this”](https://zh.javascript.info/arrow-functions#jian-tou-han-shu-mei-you-this)，不能对箭头函数进行 `new` 操作 ![[Pasted image 20231024160206.png]]
	2. ## [箭头函数没有 “arguments”](https://zh.javascript.info/arrow-functions#jian-tou-han-shu-mei-you-arguments)
	3. ## [总结](https://zh.javascript.info/arrow-functions#zong-jie)箭头函数：
		- 没有 `this`
		- 没有 `arguments`
		- 不能使用 `new` 进行调用
		- 它们也没有 `super`，但目前我们还没有学到它。我们将在 [类继承](https://zh.javascript.info/class-inheritance) 一章中学习它。
		这是因为，箭头函数是针对那些没有自己的“上下文”，但在当前上下文中起作用的短代码的。并且箭头函数确实在这种使用场景中大放异彩。

101. [ ] # 属性标志和属性描述符 第一种是 **数据属性**。![[Pasted image 20231024162136.png]]
102. [ ] # 属性的 getter 和 setter 它是 **访问器属性（accessor property）**![[Pasted image 20231024162152.png]]
103. 继承
	1. 原型继承
		1. ## [[[Prototype]]](https://zh.javascript.info/prototype-inheritance#prototype)属性 `[[Prototype]]` 是内部的而且是隐藏的，但是这儿有很多设置它的方式。
			其中之一就是使用特殊的名字 `__proto__`。当我们从 `object` 中读取一个缺失的属性时，JavaScript 会自动从原型中获取该属性。![[Pasted image 20231024164836.png]]
		2. ## [写入不使用原型](https://zh.javascript.info/prototype-inheritance#xie-ru-bu-shi-yong-yuan-xing) **无论在哪里找到方法：在一个对象还是在原型中。在一个方法调用中，`this` 始终是点符号 `.` 前面的对象。** 因此，setter 调用 `admin.fullName=` 使用 `admin` 作为 `this`，而不是 `user`。如果我们还有从 `animal` 继承的其他对象，像 `bird` 和 `snake` 等，它们也将可以访问 `animal` 的方法。但是，每个方法调用中的 `this` 都是在调用时（点符号前）评估的对应的对象，而不是 `animal`。因此，当我们将数据写入 `this` 时，会将其存储到这些对象中。所以，方法是共享的，但对象状态不是。
		3. for in 循环![[Pasted image 20231024165019.png]]
		4. 答案很简单：它是不可枚举的。就像 `Object.prototype` 的其他属性，`hasOwnProperty` 有 `enumerable:false` 标志。并且 `for..in` 只会列出可枚举的属性。这就是为什么它和其余的 `Object.prototype` 属性都未被列出。
		5. ## [总结](https://zh.javascript.info/prototype-inheritance#zong-jie)
			- 在 JavaScript 中，所有的对象都有一个隐藏的 `[[Prototype]]` 属性，它要么是另一个对象，要么就是 `null`。
			- 我们可以使用 `obj.__proto__` 访问它（历史遗留下来的 getter/setter，这儿还有其他方法，很快我们就会讲到）。
			- 通过 `[[Prototype]]` 引用的对象被称为“原型”。
			- 如果我们想要读取 `obj` 的一个属性或者调用一个方法，并且它不存在，那么 JavaScript 就会尝试在原型中查找它。
			- 写/删除操作直接在对象上进行，它们不使用原型（假设它是数据属性，不是 setter）。
			- 如果我们调用 `obj.method()`，而且 `method` 是从原型中获取的，`this` 仍然会引用 `obj`。因此，方法始终与当前对象一起使用，即使方法是继承的。
			- `for..in` 循环在其自身和继承的属性上进行迭代。所有其他的键/值获取方法仅对对象本身起作用。
	2. # F.prototype
		1. ![[Pasted image 20231024165721.png]]
		2. ![[Pasted image 20231024165803.png]]
		3. ![[Pasted image 20231024165856.png]]
		4. 在本章中，我们简要介绍了为通过构造函数创建的对象设置 `[[Prototype]]` 的方法。稍后我们将看到更多依赖于此的高级编程模式。	
			一切都很简单，只需要记住几条重点就可以清晰地掌握了：
			- **`F.prototype` 属性（不要把它与 `[[Prototype]]` 弄混了）在 `new F` 被调用时为新对象的 `[[Prototype]]` 赋值。**
			- `F.prototype` 的值要么是一个对象，要么就是 `null`：其他值都不起作用。
			- `"prototype"` 属性仅当设置在一个构造函数上，并通过 `new` 调用时，才具有这种特殊的影响。![[Pasted image 20231024170329.png]]
			- ![[Pasted image 20231024171243.png]]
			- ![[Pasted image 20231024171456.png]]
			- ![[Pasted image 20231024171507.png]]
			- ## [总结](https://zh.javascript.info/native-prototypes#zong-jie)
				- 所有的内建对象都遵循相同的模式（pattern）：
				    - 方法都存储在 prototype 中（`Array.prototype`、`Object.prototype`、`Date.prototype` 等）。
				    - 对象本身只存储数据（数组元素、对象属性、日期）。
				- 原始数据类型也将方法存储在包装器对象的 prototype 中：`Number.prototype`、`String.prototype` 和 `Boolean.prototype`。只有 `undefined` 和 `null` 没有包装器对象。
				- 内建原型可以被修改或被用新的方法填充。但是不建议更改它们。唯一允许的情况可能是，当我们添加一个还没有被 JavaScript 引擎支持，但已经被加入 JavaScript 规范的新标准时，才可能允许这样做。
	3. # 原型方法，没有 __proto__ 的对象
		1. ![[Pasted image 20231024172025.png]]
		2. ![[Pasted image 20231024172744.png]]
101. class类 
	1. 类的方法之间没有逗号：对于新手开发人员来说，常见的陷阱是在类的方法之间放置逗号，这会导致语法错误。不要把这里的符号与对象字面量相混淆。在类中，不需要逗号。
	2. ![[Pasted image 20231024174709.png]]
	3. ![[Pasted image 20231024174657.png]]
	4. # 类继承
		1. ## [总结](https://zh.javascript.info/class-inheritance#zong-jie)
			1. 想要扩展一个类：`class Child extends Parent`：
			    - 这意味着 `Child.prototype.__proto__` 将是 `Parent.prototype`，所以方法会被继承。
			2. 重写一个 constructor：
			    - 在使用 `this` 之前，我们必须在 `Child` 的 constructor 中将父 constructor 调用为 `super()`。
			3. 重写一个方法：
			    - 我们可以在一个 `Child` 方法中使用 `super.method()` 来调用 `Parent` 方法。
			4. 内部：
			    - 方法在内部的 `[[HomeObject]]` 属性中记住了它们的类/对象。这就是 `super` 如何解析父方法的。
			    - 因此，将一个带有 `super` 的方法从一个对象复制到另一个对象是不安全的。
			补充：
			- 箭头函数没有自己的 `this` 或 `super`，所以它们能融入到就近的上下文中，像透明似的。
		2. 类字段和类constructor中使用this添加的属性的区别：
			1. 类字段是保存信息的变量，字段可以附加到两个实体：
				1. 类实例上的字段
				2. 类本身的字段(也称为静态字段)
			2. 字段有两种级别可访问性：
				1. public:该字段可以在任何地方访问  
				2. private:字段只能在类的主体中访问
			3. constructor中使用this添加的属性：属于**公共实例字段**
			4. **在类的主体中定义字段**：以这种方式声明的公共字段具有表现力：快速查看字段声明就足以了解类的数据结构，而且，类字段可以在声明时立即初始化。也属于**公共实例字段**
		3. **父类构造器总是会使用它自己字段的值，而不是被重写的那一个。** 原因在于字段初始化的顺序。类字段是这样初始化的：
			- 对于基类（还未继承任何东西的那种），在构造函数调用前初始化。
			- 对于派生类，在 `super()` 后立刻初始化。
			- 幸运的是，这种行为仅在一个被重写的字段被父类构造器使用时才会显现出来。如果出问题了，我们可以通过使用方法或者 getter/setter 替代类字段，来修复这个问题。
		4.  深入：内部探究和 `[[HomeObject]]`， 探索继承和 `super` 背后的内部机制
			1. 为了提供解决方法，JavaScript 为函数添加了一个特殊的内部属性：`[[HomeObject]]`。
				当一个函数被定义为类或者对象方法时，它的 `[[HomeObject]]` 属性就成为了该对象。
				然后 `super` 使用它来解析（resolve）父原型及其方法。
				它基于 `[[HomeObject]]` 运行机制按照预期执行。一个方法，例如 `longEar.eat`，知道其 `[[HomeObject]]` 并且从其原型中获取父方法。并没有使用 `this`。
			2. ### [方法，不是函数属性](https://zh.javascript.info/class-inheritance#fang-fa-bu-shi-han-shu-shu-xing)
				`[[HomeObject]]` 是为类和普通对象中的方法定义的。但是对于对象而言，方法必须确切指定为 `method()`，而不是 `"method: function()"`。
				这个差别对我们来说可能不重要，但是对 JavaScript 来说却非常重要。
				在下面的例子中，使用非方法（non-method）语法进行了比较。未设置 `[[HomeObject]]` 属性，并且继承无效：
		5. ## [总结](https://zh.javascript.info/class-inheritance#zong-jie)
			1. 想要扩展一个类：`class Child extends Parent`：
			    - 这意味着 `Child.prototype.__proto__` 将是 `Parent.prototype`，所以方法会被继承。
			2. 重写一个 constructor：
			    - 在使用 `this` 之前，我们必须在 `Child` 的 constructor 中将父 constructor 调用为 `super()`。
			3. 重写一个方法：
			    - 我们可以在一个 `Child` 方法中使用 `super.method()` 来调用 `Parent` 方法。
			4. 内部：
			    - 方法在内部的 `[[HomeObject]]` 属性中记住了它们的类/对象。这就是 `super` 如何解析父方法的。
			    - 因此，将一个带有 `super` 的方法从一个对象复制到另一个对象是不安全的。
			补充：
			- 箭头函数没有自己的 `this` 或 `super`，所以它们能融入到就近的上下文中，像透明似的。
	5. # 静态属性和静态方法 :[从__proto__和prototype来深入理解JS对象和原型链 · Issue #9 · creeperyang/blog (github.com)](https://github.com/creeperyang/blog/issues/9)![[Pasted image 20231025110846.png]]
		1. 构造函数都继承于Function.prototype，因为对于内建的 `Object` 构造函数而言，`Object.__proto__ === Function.prototype`。
		2. `Function.__proto__ === Function.prototype`
		3. `Function.__proto__.__proto__ === Object.prototype;`
		4. Function和Object的关系
			这是JavaScript比较奇葩的一个地方，也是不太让人容易接受的一点。
			我们知道一般任何对象都是Object的instance，因为原型链的顶端都指向Object.prototype。那么Object本身是什么？Object也是个函数，而任何函数都是Function的实例对象，比如Array，String，当然Object也包括在内，它也是Function的实例，即：
			```
			Object.__proto__ === Function.prototype;
			Object instanceof Function === true
			```
			同时，Function是个对象，它的原型是Function.__proto__，指向Function.prototype，并且这个原型链向上继续指向Object.prototype，即：
			```
			Function.__proto__.__proto__ === Object.prototype;
			Function instanceof Object === true
			```
			这样就有了一个JavaScript里经常说到的蛋鸡问题：
				Object instanceof Function === true
				Function instanceof Object === true
			[JavaScript原型链以及Object，Function之间的关系 - 一抹夏忧☆ - 博客园 (cnblogs.com)](https://www.cnblogs.com/web-record/p/9661804.html)
			![[Pasted image 20231025115525.png]]
			这里要注意继承关系，类-原型继承-类，类的原型-原型继承-类的原型
		* 为了隐藏内部接口，我们使用受保护的或私有的属性：
			- 受保护的字段以 `_` 开头。这是一个众所周知的约定，不是在语言级别强制执行的。程序员应该只通过它的类和从它继承的类中访问以 `_` 开头的字段。
			- 私有字段以 `#` 开头。JavaScript 确保我们只能从类的内部访问它们。
	6. # 扩展内建类：其他集合，例如 `Map` 和 `Set` 的工作方式类似。它们也使用 `Symbol.species`。![[Pasted image 20231025173009.png]]
	7. # 类检查："instanceof"
		`instanceof` 操作符用于检查一个对象是否属于某个特定的 class。同时，它还考虑了继承。在许多情况下，可能都需要进行此类检查。例如，它可以被用来构建一个 **多态性（polymorphic）** 的函数，该函数根据参数的类型对参数进行不同的处理。![[Pasted image 20231025173212.png]]
		通常，`instanceof` 在检查中会将原型链考虑在内。此外，我们还可以在静态方法 `Symbol.hasInstance` 中设置自定义逻辑。
		如果这儿有静态方法 `Symbol.hasInstance`，那就直接调用这个方法
		大多数 class 没有 `Symbol.hasInstance`。在这种情况下，标准的逻辑是：使用 `obj instanceOf Class` 检查 `Class.prototype` 是否等于 `obj` 的原型链中的原型之一。
		这里还要提到一个方法 [objA.isPrototypeOf(objB)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/object/isPrototypeOf)，如果 `objA` 处在 `objB` 的原型链中，则返回 `true`。所以，可以将 `obj instanceof Class` 检查改为 `Class.prototype.isPrototypeOf(obj)`。
		如果我们想要获取内建对象的类型，并希望把该信息以字符串的形式返回，而不只是检查类型的话，我们可以用 `{}.toString.call` 替代 `instanceof`。![[Pasted image 20231025174039.png]]
		`instanceof` 并不关心函数，而是关心函数的与原型链匹配的 `prototype`。

		并且，这里 `a.__proto__ == B.prototype`，所以 `instanceof` 返回 `true`。
		
		总之，根据 `instanceof` 的逻辑，真正决定类型的是 `prototype`，而不是构造函数。
	8. # Mixin 模式
		1. ## [总结](https://zh.javascript.info/mixins#zong-jie)
			_Mixin_ —— 是一个通用的面向对象编程术语：一个包含其他类的方法的类。
			一些其它编程语言允许多重继承。JavaScript 不支持多重继承，但是可以通过将方法拷贝到原型中来实现 mixin。
			我们可以使用 mixin 作为一种通过添加多种行为（例如上文中所提到的事件处理）来扩充类的方法。
			如果 Mixins 意外覆盖了现有类的方法，那么它们可能会成为一个冲突点。因此，通常应该仔细考虑 mixin 的命名方法，以最大程度地降低发生这种冲突的可能性。